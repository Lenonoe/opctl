// This file was generated by counterfeiter
package fake

import (
  "sync"

  "github.com/dev-op-spec/engine/core/models"
  "github.com/dev-op-spec/engine/core/ports"
)

func New() ports.ContainerEngine {
  return &containerEngine{}
}

type containerEngine struct {
  InitOpStub        func(pathToOpDir string, name string) (err error)
  initOpMutex       sync.RWMutex
  initOpArgsForCall []struct {
    pathToOpDir string
    name        string
  }
  initOpReturns     struct {
                      result1 error
                    }
  RunOpStub         func(pathToOpDir string, name string) (exitCode int, logChannel chan *models.LogEntry, err error)
  runOpMutex        sync.RWMutex
  runOpArgsForCall  []struct {
    pathToOpDir string
    name        string
  }
  runOpReturns      struct {
                      result1 int
                      result2 chan *models.LogEntry
                      result3 error
                    }
}

func (fake *containerEngine) InitOp(pathToOpDir string, name string) (err error) {
  fake.initOpMutex.Lock()
  fake.initOpArgsForCall = append(fake.initOpArgsForCall, struct {
    pathToOpDir string
    name        string
  }{pathToOpDir, name})
  fake.initOpMutex.Unlock()
  if fake.InitOpStub != nil {
    return fake.InitOpStub(pathToOpDir, name)
  } else {
    return fake.initOpReturns.result1
  }
}

func (fake *containerEngine) InitOpCallCount() int {
  fake.initOpMutex.RLock()
  defer fake.initOpMutex.RUnlock()
  return len(fake.initOpArgsForCall)
}

func (fake *containerEngine) InitOpArgsForCall(i int) (string, string) {
  fake.initOpMutex.RLock()
  defer fake.initOpMutex.RUnlock()
  return fake.initOpArgsForCall[i].pathToOpDir, fake.initOpArgsForCall[i].name
}

func (fake *containerEngine) InitOpReturns(result1 error) {
  fake.InitOpStub = nil
  fake.initOpReturns = struct {
    result1 error
  }{result1}
}

func (fake *containerEngine) RunOp(pathToOpDir string, name string) (exitCode int, logChannel chan *models.LogEntry, err error) {
  fake.runOpMutex.Lock()
  fake.runOpArgsForCall = append(fake.runOpArgsForCall, struct {
    pathToOpDir string
    name        string
  }{pathToOpDir, name})
  fake.runOpMutex.Unlock()
  if fake.RunOpStub != nil {
    return fake.RunOpStub(pathToOpDir, name)
  } else {
    return fake.runOpReturns.result1, fake.runOpReturns.result2, fake.runOpReturns.result3
  }
}

func (fake *containerEngine) RunOpCallCount() int {
  fake.runOpMutex.RLock()
  defer fake.runOpMutex.RUnlock()
  return len(fake.runOpArgsForCall)
}

func (fake *containerEngine) RunOpArgsForCall(i int) (string, string) {
  fake.runOpMutex.RLock()
  defer fake.runOpMutex.RUnlock()
  return fake.runOpArgsForCall[i].pathToOpDir, fake.runOpArgsForCall[i].name
}

func (fake *containerEngine) RunOpReturns(result1 int, result2 chan *models.LogEntry, result3 error) {
  fake.RunOpStub = nil
  fake.runOpReturns = struct {
    result1 int
    result2 chan *models.LogEntry
    result3 error
  }{result1, result2, result3}
}

var _ ports.ContainerEngine = new(containerEngine)
