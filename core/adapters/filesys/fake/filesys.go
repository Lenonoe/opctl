// This file was generated by counterfeiter
package fake

import (
  "sync"

  "github.com/dev-op-spec/engine/core/ports"
)

func New(
) ports.Filesys {

  return &fakeFilesys{}

}

type fakeFilesys struct {
  CreateDirStub                   func(pathToDir string) (err error)
  createDirMutex                  sync.RWMutex
  createDirArgsForCall            []struct {
    pathToDir string
  }
  createDirReturns                struct {
                                    result1 error
                                  }
  ListNamesOfChildDirsStub        func(pathToPERATIONarentDir string) (namesOfChildDirs []string, err error)
  listNamesOfChildDirsMutex       sync.RWMutex
  listNamesOfChildDirsArgsForCall []struct {
    pathToPERATIONarentDir string
  }
  listNamesOfChildDirsReturns     struct {
                                    result1 []string
                                    result2 error
                                  }
  GetBytesOfFileStub              func(pathToFile string) (bytesOfFile []byte, err error)
  getBytesOfFileMutex             sync.RWMutex
  getBytesOfFileArgsForCall       []struct {
    pathToFile string
  }
  getBytesOfFileReturns           struct {
                                    result1 []byte
                                    result2 error
                                  }
  SaveFileStub                    func(pathToFile string, bytesOfFile []byte) (err error)
  saveFileMutex                   sync.RWMutex
  saveFileArgsForCall             []struct {
    pathToFile  string
    bytesOfFile []byte
  }
  saveFileReturns                 struct {
                                    result1 error
                                  }
}

func (fake *fakeFilesys) CreateDir(pathToDir string) (err error) {
  fake.createDirMutex.Lock()
  fake.createDirArgsForCall = append(fake.createDirArgsForCall, struct {
    pathToDir string
  }{pathToDir})
  fake.createDirMutex.Unlock()
  if fake.CreateDirStub != nil {
    return fake.CreateDirStub(pathToDir)
  } else {
    return fake.createDirReturns.result1
  }
}

func (fake *fakeFilesys) CreateDirCallCount() int {
  fake.createDirMutex.RLock()
  defer fake.createDirMutex.RUnlock()
  return len(fake.createDirArgsForCall)
}

func (fake *fakeFilesys) CreateDirArgsForCall(i int) string {
  fake.createDirMutex.RLock()
  defer fake.createDirMutex.RUnlock()
  return fake.createDirArgsForCall[i].pathToDir
}

func (fake *fakeFilesys) CreateDirReturns(result1 error) {
  fake.CreateDirStub = nil
  fake.createDirReturns = struct {
    result1 error
  }{result1}
}

func (fake *fakeFilesys) ListNamesOfChildDirs(pathToPERATIONarentDir string) (namesOfChildDirs []string, err error) {
  fake.listNamesOfChildDirsMutex.Lock()
  fake.listNamesOfChildDirsArgsForCall = append(fake.listNamesOfChildDirsArgsForCall, struct {
    pathToPERATIONarentDir string
  }{pathToPERATIONarentDir})
  fake.listNamesOfChildDirsMutex.Unlock()
  if fake.ListNamesOfChildDirsStub != nil {
    return fake.ListNamesOfChildDirsStub(pathToPERATIONarentDir)
  } else {
    return fake.listNamesOfChildDirsReturns.result1, fake.listNamesOfChildDirsReturns.result2
  }
}

func (fake *fakeFilesys) ListNamesOfChildDirsCallCount() int {
  fake.listNamesOfChildDirsMutex.RLock()
  defer fake.listNamesOfChildDirsMutex.RUnlock()
  return len(fake.listNamesOfChildDirsArgsForCall)
}

func (fake *fakeFilesys) ListNamesOfChildDirsArgsForCall(i int) string {
  fake.listNamesOfChildDirsMutex.RLock()
  defer fake.listNamesOfChildDirsMutex.RUnlock()
  return fake.listNamesOfChildDirsArgsForCall[i].pathToPERATIONarentDir
}

func (fake *fakeFilesys) ListNamesOfChildDirsReturns(result1 []string, result2 error) {
  fake.ListNamesOfChildDirsStub = nil
  fake.listNamesOfChildDirsReturns = struct {
    result1 []string
    result2 error
  }{result1, result2}
}

func (fake *fakeFilesys) GetBytesOfFile(pathToFile string) (bytesOfFile []byte, err error) {
  fake.getBytesOfFileMutex.Lock()
  fake.getBytesOfFileArgsForCall = append(fake.getBytesOfFileArgsForCall, struct {
    pathToFile string
  }{pathToFile})
  fake.getBytesOfFileMutex.Unlock()
  if fake.GetBytesOfFileStub != nil {
    return fake.GetBytesOfFileStub(pathToFile)
  } else {
    return fake.getBytesOfFileReturns.result1, fake.getBytesOfFileReturns.result2
  }
}

func (fake *fakeFilesys) GetBytesOfFileCallCount() int {
  fake.getBytesOfFileMutex.RLock()
  defer fake.getBytesOfFileMutex.RUnlock()
  return len(fake.getBytesOfFileArgsForCall)
}

func (fake *fakeFilesys) GetBytesOfFileArgsForCall(i int) string {
  fake.getBytesOfFileMutex.RLock()
  defer fake.getBytesOfFileMutex.RUnlock()
  return fake.getBytesOfFileArgsForCall[i].pathToFile
}

func (fake *fakeFilesys) GetBytesOfFileReturns(result1 []byte, result2 error) {
  fake.GetBytesOfFileStub = nil
  fake.getBytesOfFileReturns = struct {
    result1 []byte
    result2 error
  }{result1, result2}
}

func (fake *fakeFilesys) SaveFile(pathToFile string, bytesOfFile []byte) (err error) {
  fake.saveFileMutex.Lock()
  fake.saveFileArgsForCall = append(fake.saveFileArgsForCall, struct {
    pathToFile  string
    bytesOfFile []byte
  }{pathToFile, bytesOfFile})
  fake.saveFileMutex.Unlock()
  if fake.SaveFileStub != nil {
    return fake.SaveFileStub(pathToFile, bytesOfFile)
  } else {
    return fake.saveFileReturns.result1
  }
}

func (fake *fakeFilesys) SaveFileCallCount() int {
  fake.saveFileMutex.RLock()
  defer fake.saveFileMutex.RUnlock()
  return len(fake.saveFileArgsForCall)
}

func (fake *fakeFilesys) SaveFileArgsForCall(i int) (string, []byte) {
  fake.saveFileMutex.RLock()
  defer fake.saveFileMutex.RUnlock()
  return fake.saveFileArgsForCall[i].pathToFile, fake.saveFileArgsForCall[i].bytesOfFile
}

func (fake *fakeFilesys) SaveFileReturns(result1 error) {
  fake.SaveFileStub = nil
  fake.saveFileReturns = struct {
    result1 error
  }{result1}
}

var _ ports.Filesys = new(fakeFilesys)
