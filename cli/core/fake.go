// This file was generated by counterfeiter
package core

import (
	"sync"
)

type Fake struct {
	CreatePackageStub        func(collection string, description string, name string)
	createPackageMutex       sync.RWMutex
	createPackageArgsForCall []struct {
		collection  string
		description string
		name        string
	}
	OpKillStub        func(opId string)
	opKillMutex       sync.RWMutex
	opKillArgsForCall []struct {
		opId string
	}
	ListPackagesStub        func(path string)
	listPackagesMutex       sync.RWMutex
	listPackagesArgsForCall []struct {
		path string
	}
	NodeCreateStub        func()
	nodeCreateMutex       sync.RWMutex
	nodeCreateArgsForCall []struct{}
	NodeKillStub          func()
	nodeKillMutex         sync.RWMutex
	nodeKillArgsForCall   []struct{}
	RunOpStub             func(args []string, pkgRef string)
	runOpMutex            sync.RWMutex
	runOpArgsForCall      []struct {
		args   []string
		pkgRef string
	}
	PkgSetDescriptionStub        func(description string, pkgRef string)
	pkgSetDescriptionMutex       sync.RWMutex
	pkgSetDescriptionArgsForCall []struct {
		description string
		pkgRef      string
	}
	StreamEventsStub        func()
	streamEventsMutex       sync.RWMutex
	streamEventsArgsForCall []struct{}
	SelfUpdateStub          func(channel string)
	selfUpdateMutex         sync.RWMutex
	selfUpdateArgsForCall   []struct {
		channel string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Fake) CreatePackage(collection string, description string, name string) {
	fake.createPackageMutex.Lock()
	fake.createPackageArgsForCall = append(fake.createPackageArgsForCall, struct {
		collection  string
		description string
		name        string
	}{collection, description, name})
	fake.recordInvocation("CreatePackage", []interface{}{collection, description, name})
	fake.createPackageMutex.Unlock()
	if fake.CreatePackageStub != nil {
		fake.CreatePackageStub(collection, description, name)
	}
}

func (fake *Fake) CreatePackageCallCount() int {
	fake.createPackageMutex.RLock()
	defer fake.createPackageMutex.RUnlock()
	return len(fake.createPackageArgsForCall)
}

func (fake *Fake) CreatePackageArgsForCall(i int) (string, string, string) {
	fake.createPackageMutex.RLock()
	defer fake.createPackageMutex.RUnlock()
	return fake.createPackageArgsForCall[i].collection, fake.createPackageArgsForCall[i].description, fake.createPackageArgsForCall[i].name
}

func (fake *Fake) OpKill(opId string) {
	fake.opKillMutex.Lock()
	fake.opKillArgsForCall = append(fake.opKillArgsForCall, struct {
		opId string
	}{opId})
	fake.recordInvocation("OpKill", []interface{}{opId})
	fake.opKillMutex.Unlock()
	if fake.OpKillStub != nil {
		fake.OpKillStub(opId)
	}
}

func (fake *Fake) OpKillCallCount() int {
	fake.opKillMutex.RLock()
	defer fake.opKillMutex.RUnlock()
	return len(fake.opKillArgsForCall)
}

func (fake *Fake) OpKillArgsForCall(i int) string {
	fake.opKillMutex.RLock()
	defer fake.opKillMutex.RUnlock()
	return fake.opKillArgsForCall[i].opId
}

func (fake *Fake) ListPackages(path string) {
	fake.listPackagesMutex.Lock()
	fake.listPackagesArgsForCall = append(fake.listPackagesArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("ListPackages", []interface{}{path})
	fake.listPackagesMutex.Unlock()
	if fake.ListPackagesStub != nil {
		fake.ListPackagesStub(path)
	}
}

func (fake *Fake) ListPackagesCallCount() int {
	fake.listPackagesMutex.RLock()
	defer fake.listPackagesMutex.RUnlock()
	return len(fake.listPackagesArgsForCall)
}

func (fake *Fake) ListPackagesArgsForCall(i int) string {
	fake.listPackagesMutex.RLock()
	defer fake.listPackagesMutex.RUnlock()
	return fake.listPackagesArgsForCall[i].path
}

func (fake *Fake) NodeCreate() {
	fake.nodeCreateMutex.Lock()
	fake.nodeCreateArgsForCall = append(fake.nodeCreateArgsForCall, struct{}{})
	fake.recordInvocation("NodeCreate", []interface{}{})
	fake.nodeCreateMutex.Unlock()
	if fake.NodeCreateStub != nil {
		fake.NodeCreateStub()
	}
}

func (fake *Fake) NodeCreateCallCount() int {
	fake.nodeCreateMutex.RLock()
	defer fake.nodeCreateMutex.RUnlock()
	return len(fake.nodeCreateArgsForCall)
}

func (fake *Fake) NodeKill() {
	fake.nodeKillMutex.Lock()
	fake.nodeKillArgsForCall = append(fake.nodeKillArgsForCall, struct{}{})
	fake.recordInvocation("NodeKill", []interface{}{})
	fake.nodeKillMutex.Unlock()
	if fake.NodeKillStub != nil {
		fake.NodeKillStub()
	}
}

func (fake *Fake) NodeKillCallCount() int {
	fake.nodeKillMutex.RLock()
	defer fake.nodeKillMutex.RUnlock()
	return len(fake.nodeKillArgsForCall)
}

func (fake *Fake) RunOp(args []string, pkgRef string) {
	var argsCopy []string
	if args != nil {
		argsCopy = make([]string, len(args))
		copy(argsCopy, args)
	}
	fake.runOpMutex.Lock()
	fake.runOpArgsForCall = append(fake.runOpArgsForCall, struct {
		args   []string
		pkgRef string
	}{argsCopy, pkgRef})
	fake.recordInvocation("RunOp", []interface{}{argsCopy, pkgRef})
	fake.runOpMutex.Unlock()
	if fake.RunOpStub != nil {
		fake.RunOpStub(args, pkgRef)
	}
}

func (fake *Fake) RunOpCallCount() int {
	fake.runOpMutex.RLock()
	defer fake.runOpMutex.RUnlock()
	return len(fake.runOpArgsForCall)
}

func (fake *Fake) RunOpArgsForCall(i int) ([]string, string) {
	fake.runOpMutex.RLock()
	defer fake.runOpMutex.RUnlock()
	return fake.runOpArgsForCall[i].args, fake.runOpArgsForCall[i].pkgRef
}

func (fake *Fake) PkgSetDescription(description string, pkgRef string) {
	fake.pkgSetDescriptionMutex.Lock()
	fake.pkgSetDescriptionArgsForCall = append(fake.pkgSetDescriptionArgsForCall, struct {
		description string
		pkgRef      string
	}{description, pkgRef})
	fake.recordInvocation("PkgSetDescription", []interface{}{description, pkgRef})
	fake.pkgSetDescriptionMutex.Unlock()
	if fake.PkgSetDescriptionStub != nil {
		fake.PkgSetDescriptionStub(description, pkgRef)
	}
}

func (fake *Fake) PkgSetDescriptionCallCount() int {
	fake.pkgSetDescriptionMutex.RLock()
	defer fake.pkgSetDescriptionMutex.RUnlock()
	return len(fake.pkgSetDescriptionArgsForCall)
}

func (fake *Fake) PkgSetDescriptionArgsForCall(i int) (string, string) {
	fake.pkgSetDescriptionMutex.RLock()
	defer fake.pkgSetDescriptionMutex.RUnlock()
	return fake.pkgSetDescriptionArgsForCall[i].description, fake.pkgSetDescriptionArgsForCall[i].pkgRef
}

func (fake *Fake) StreamEvents() {
	fake.streamEventsMutex.Lock()
	fake.streamEventsArgsForCall = append(fake.streamEventsArgsForCall, struct{}{})
	fake.recordInvocation("StreamEvents", []interface{}{})
	fake.streamEventsMutex.Unlock()
	if fake.StreamEventsStub != nil {
		fake.StreamEventsStub()
	}
}

func (fake *Fake) StreamEventsCallCount() int {
	fake.streamEventsMutex.RLock()
	defer fake.streamEventsMutex.RUnlock()
	return len(fake.streamEventsArgsForCall)
}

func (fake *Fake) SelfUpdate(channel string) {
	fake.selfUpdateMutex.Lock()
	fake.selfUpdateArgsForCall = append(fake.selfUpdateArgsForCall, struct {
		channel string
	}{channel})
	fake.recordInvocation("SelfUpdate", []interface{}{channel})
	fake.selfUpdateMutex.Unlock()
	if fake.SelfUpdateStub != nil {
		fake.SelfUpdateStub(channel)
	}
}

func (fake *Fake) SelfUpdateCallCount() int {
	fake.selfUpdateMutex.RLock()
	defer fake.selfUpdateMutex.RUnlock()
	return len(fake.selfUpdateArgsForCall)
}

func (fake *Fake) SelfUpdateArgsForCall(i int) string {
	fake.selfUpdateMutex.RLock()
	defer fake.selfUpdateMutex.RUnlock()
	return fake.selfUpdateArgsForCall[i].channel
}

func (fake *Fake) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createPackageMutex.RLock()
	defer fake.createPackageMutex.RUnlock()
	fake.opKillMutex.RLock()
	defer fake.opKillMutex.RUnlock()
	fake.listPackagesMutex.RLock()
	defer fake.listPackagesMutex.RUnlock()
	fake.nodeCreateMutex.RLock()
	defer fake.nodeCreateMutex.RUnlock()
	fake.nodeKillMutex.RLock()
	defer fake.nodeKillMutex.RUnlock()
	fake.runOpMutex.RLock()
	defer fake.runOpMutex.RUnlock()
	fake.pkgSetDescriptionMutex.RLock()
	defer fake.pkgSetDescriptionMutex.RUnlock()
	fake.streamEventsMutex.RLock()
	defer fake.streamEventsMutex.RUnlock()
	fake.selfUpdateMutex.RLock()
	defer fake.selfUpdateMutex.RUnlock()
	return fake.invocations
}

func (fake *Fake) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ Core = new(Fake)
