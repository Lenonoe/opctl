// Code generated by counterfeiter. DO NOT EDIT.
package core

import (
	"sync"
)

type Fake struct {
	OpKillStub        func(opId string)
	opKillMutex       sync.RWMutex
	opKillArgsForCall []struct {
		opId string
	}
	NodeCreateStub        func()
	nodeCreateMutex       sync.RWMutex
	nodeCreateArgsForCall []struct{}
	NodeKillStub          func()
	nodeKillMutex         sync.RWMutex
	nodeKillArgsForCall   []struct{}
	RunStub               func(pkgRef string, opts *RunOpts)
	runMutex              sync.RWMutex
	runArgsForCall        []struct {
		pkgRef string
		opts   *RunOpts
	}
	PkgCreateStub        func(path string, description string, name string)
	pkgCreateMutex       sync.RWMutex
	pkgCreateArgsForCall []struct {
		path        string
		description string
		name        string
	}
	PkgLsStub        func(path string)
	pkgLsMutex       sync.RWMutex
	pkgLsArgsForCall []struct {
		path string
	}
	PkgInstallStub        func(path, pkgRef, username, password string)
	pkgInstallMutex       sync.RWMutex
	pkgInstallArgsForCall []struct {
		path     string
		pkgRef   string
		username string
		password string
	}
	PkgValidateStub        func(pkgRef string)
	pkgValidateMutex       sync.RWMutex
	pkgValidateArgsForCall []struct {
		pkgRef string
	}
	EventsStub            func()
	eventsMutex           sync.RWMutex
	eventsArgsForCall     []struct{}
	SelfUpdateStub        func(channel string)
	selfUpdateMutex       sync.RWMutex
	selfUpdateArgsForCall []struct {
		channel string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Fake) OpKill(opId string) {
	fake.opKillMutex.Lock()
	fake.opKillArgsForCall = append(fake.opKillArgsForCall, struct {
		opId string
	}{opId})
	fake.recordInvocation("OpKill", []interface{}{opId})
	fake.opKillMutex.Unlock()
	if fake.OpKillStub != nil {
		fake.OpKillStub(opId)
	}
}

func (fake *Fake) OpKillCallCount() int {
	fake.opKillMutex.RLock()
	defer fake.opKillMutex.RUnlock()
	return len(fake.opKillArgsForCall)
}

func (fake *Fake) OpKillArgsForCall(i int) string {
	fake.opKillMutex.RLock()
	defer fake.opKillMutex.RUnlock()
	return fake.opKillArgsForCall[i].opId
}

func (fake *Fake) NodeCreate() {
	fake.nodeCreateMutex.Lock()
	fake.nodeCreateArgsForCall = append(fake.nodeCreateArgsForCall, struct{}{})
	fake.recordInvocation("NodeCreate", []interface{}{})
	fake.nodeCreateMutex.Unlock()
	if fake.NodeCreateStub != nil {
		fake.NodeCreateStub()
	}
}

func (fake *Fake) NodeCreateCallCount() int {
	fake.nodeCreateMutex.RLock()
	defer fake.nodeCreateMutex.RUnlock()
	return len(fake.nodeCreateArgsForCall)
}

func (fake *Fake) NodeKill() {
	fake.nodeKillMutex.Lock()
	fake.nodeKillArgsForCall = append(fake.nodeKillArgsForCall, struct{}{})
	fake.recordInvocation("NodeKill", []interface{}{})
	fake.nodeKillMutex.Unlock()
	if fake.NodeKillStub != nil {
		fake.NodeKillStub()
	}
}

func (fake *Fake) NodeKillCallCount() int {
	fake.nodeKillMutex.RLock()
	defer fake.nodeKillMutex.RUnlock()
	return len(fake.nodeKillArgsForCall)
}

func (fake *Fake) Run(pkgRef string, opts *RunOpts) {
	fake.runMutex.Lock()
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
		pkgRef string
		opts   *RunOpts
	}{pkgRef, opts})
	fake.recordInvocation("Run", []interface{}{pkgRef, opts})
	fake.runMutex.Unlock()
	if fake.RunStub != nil {
		fake.RunStub(pkgRef, opts)
	}
}

func (fake *Fake) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *Fake) RunArgsForCall(i int) (string, *RunOpts) {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return fake.runArgsForCall[i].pkgRef, fake.runArgsForCall[i].opts
}

func (fake *Fake) PkgCreate(path string, description string, name string) {
	fake.pkgCreateMutex.Lock()
	fake.pkgCreateArgsForCall = append(fake.pkgCreateArgsForCall, struct {
		path        string
		description string
		name        string
	}{path, description, name})
	fake.recordInvocation("PkgCreate", []interface{}{path, description, name})
	fake.pkgCreateMutex.Unlock()
	if fake.PkgCreateStub != nil {
		fake.PkgCreateStub(path, description, name)
	}
}

func (fake *Fake) PkgCreateCallCount() int {
	fake.pkgCreateMutex.RLock()
	defer fake.pkgCreateMutex.RUnlock()
	return len(fake.pkgCreateArgsForCall)
}

func (fake *Fake) PkgCreateArgsForCall(i int) (string, string, string) {
	fake.pkgCreateMutex.RLock()
	defer fake.pkgCreateMutex.RUnlock()
	return fake.pkgCreateArgsForCall[i].path, fake.pkgCreateArgsForCall[i].description, fake.pkgCreateArgsForCall[i].name
}

func (fake *Fake) PkgLs(path string) {
	fake.pkgLsMutex.Lock()
	fake.pkgLsArgsForCall = append(fake.pkgLsArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("PkgLs", []interface{}{path})
	fake.pkgLsMutex.Unlock()
	if fake.PkgLsStub != nil {
		fake.PkgLsStub(path)
	}
}

func (fake *Fake) PkgLsCallCount() int {
	fake.pkgLsMutex.RLock()
	defer fake.pkgLsMutex.RUnlock()
	return len(fake.pkgLsArgsForCall)
}

func (fake *Fake) PkgLsArgsForCall(i int) string {
	fake.pkgLsMutex.RLock()
	defer fake.pkgLsMutex.RUnlock()
	return fake.pkgLsArgsForCall[i].path
}

func (fake *Fake) PkgInstall(path string, pkgRef string, username string, password string) {
	fake.pkgInstallMutex.Lock()
	fake.pkgInstallArgsForCall = append(fake.pkgInstallArgsForCall, struct {
		path     string
		pkgRef   string
		username string
		password string
	}{path, pkgRef, username, password})
	fake.recordInvocation("PkgInstall", []interface{}{path, pkgRef, username, password})
	fake.pkgInstallMutex.Unlock()
	if fake.PkgInstallStub != nil {
		fake.PkgInstallStub(path, pkgRef, username, password)
	}
}

func (fake *Fake) PkgInstallCallCount() int {
	fake.pkgInstallMutex.RLock()
	defer fake.pkgInstallMutex.RUnlock()
	return len(fake.pkgInstallArgsForCall)
}

func (fake *Fake) PkgInstallArgsForCall(i int) (string, string, string, string) {
	fake.pkgInstallMutex.RLock()
	defer fake.pkgInstallMutex.RUnlock()
	return fake.pkgInstallArgsForCall[i].path, fake.pkgInstallArgsForCall[i].pkgRef, fake.pkgInstallArgsForCall[i].username, fake.pkgInstallArgsForCall[i].password
}

func (fake *Fake) PkgValidate(pkgRef string) {
	fake.pkgValidateMutex.Lock()
	fake.pkgValidateArgsForCall = append(fake.pkgValidateArgsForCall, struct {
		pkgRef string
	}{pkgRef})
	fake.recordInvocation("PkgValidate", []interface{}{pkgRef})
	fake.pkgValidateMutex.Unlock()
	if fake.PkgValidateStub != nil {
		fake.PkgValidateStub(pkgRef)
	}
}

func (fake *Fake) PkgValidateCallCount() int {
	fake.pkgValidateMutex.RLock()
	defer fake.pkgValidateMutex.RUnlock()
	return len(fake.pkgValidateArgsForCall)
}

func (fake *Fake) PkgValidateArgsForCall(i int) string {
	fake.pkgValidateMutex.RLock()
	defer fake.pkgValidateMutex.RUnlock()
	return fake.pkgValidateArgsForCall[i].pkgRef
}

func (fake *Fake) Events() {
	fake.eventsMutex.Lock()
	fake.eventsArgsForCall = append(fake.eventsArgsForCall, struct{}{})
	fake.recordInvocation("Events", []interface{}{})
	fake.eventsMutex.Unlock()
	if fake.EventsStub != nil {
		fake.EventsStub()
	}
}

func (fake *Fake) EventsCallCount() int {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return len(fake.eventsArgsForCall)
}

func (fake *Fake) SelfUpdate(channel string) {
	fake.selfUpdateMutex.Lock()
	fake.selfUpdateArgsForCall = append(fake.selfUpdateArgsForCall, struct {
		channel string
	}{channel})
	fake.recordInvocation("SelfUpdate", []interface{}{channel})
	fake.selfUpdateMutex.Unlock()
	if fake.SelfUpdateStub != nil {
		fake.SelfUpdateStub(channel)
	}
}

func (fake *Fake) SelfUpdateCallCount() int {
	fake.selfUpdateMutex.RLock()
	defer fake.selfUpdateMutex.RUnlock()
	return len(fake.selfUpdateArgsForCall)
}

func (fake *Fake) SelfUpdateArgsForCall(i int) string {
	fake.selfUpdateMutex.RLock()
	defer fake.selfUpdateMutex.RUnlock()
	return fake.selfUpdateArgsForCall[i].channel
}

func (fake *Fake) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.opKillMutex.RLock()
	defer fake.opKillMutex.RUnlock()
	fake.nodeCreateMutex.RLock()
	defer fake.nodeCreateMutex.RUnlock()
	fake.nodeKillMutex.RLock()
	defer fake.nodeKillMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.pkgCreateMutex.RLock()
	defer fake.pkgCreateMutex.RUnlock()
	fake.pkgLsMutex.RLock()
	defer fake.pkgLsMutex.RUnlock()
	fake.pkgInstallMutex.RLock()
	defer fake.pkgInstallMutex.RUnlock()
	fake.pkgValidateMutex.RLock()
	defer fake.pkgValidateMutex.RUnlock()
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	fake.selfUpdateMutex.RLock()
	defer fake.selfUpdateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Fake) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ Core = new(Fake)
