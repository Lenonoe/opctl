// This file was generated by counterfeiter
package docker

import (
	"io"
	"sync"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/network"
	"golang.org/x/net/context"
)

type fakeDockerClient struct {
	ContainerCreateStub        func(ctx context.Context, config *container.Config, hostConfig *container.HostConfig, networkingConfig *network.NetworkingConfig, containerName string) (container.ContainerCreateCreatedBody, error)
	containerCreateMutex       sync.RWMutex
	containerCreateArgsForCall []struct {
		ctx              context.Context
		config           *container.Config
		hostConfig       *container.HostConfig
		networkingConfig *network.NetworkingConfig
		containerName    string
	}
	containerCreateReturns struct {
		result1 container.ContainerCreateCreatedBody
		result2 error
	}
	ContainerInspectStub        func(ctx context.Context, containerID string) (types.ContainerJSON, error)
	containerInspectMutex       sync.RWMutex
	containerInspectArgsForCall []struct {
		ctx         context.Context
		containerID string
	}
	containerInspectReturns struct {
		result1 types.ContainerJSON
		result2 error
	}
	ContainerLogsStub        func(ctx context.Context, container string, options types.ContainerLogsOptions) (io.ReadCloser, error)
	containerLogsMutex       sync.RWMutex
	containerLogsArgsForCall []struct {
		ctx       context.Context
		container string
		options   types.ContainerLogsOptions
	}
	containerLogsReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	ContainerRemoveStub        func(ctx context.Context, containerID string, options types.ContainerRemoveOptions) error
	containerRemoveMutex       sync.RWMutex
	containerRemoveArgsForCall []struct {
		ctx         context.Context
		containerID string
		options     types.ContainerRemoveOptions
	}
	containerRemoveReturns struct {
		result1 error
	}
	ContainerStartStub        func(ctx context.Context, containerID string, options types.ContainerStartOptions) error
	containerStartMutex       sync.RWMutex
	containerStartArgsForCall []struct {
		ctx         context.Context
		containerID string
		options     types.ContainerStartOptions
	}
	containerStartReturns struct {
		result1 error
	}
	ContainerWaitStub        func(ctx context.Context, containerID string) (int64, error)
	containerWaitMutex       sync.RWMutex
	containerWaitArgsForCall []struct {
		ctx         context.Context
		containerID string
	}
	containerWaitReturns struct {
		result1 int64
		result2 error
	}
	ImagePullStub        func(ctx context.Context, ref string, options types.ImagePullOptions) (io.ReadCloser, error)
	imagePullMutex       sync.RWMutex
	imagePullArgsForCall []struct {
		ctx     context.Context
		ref     string
		options types.ImagePullOptions
	}
	imagePullReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *fakeDockerClient) ContainerCreate(ctx context.Context, config *container.Config, hostConfig *container.HostConfig, networkingConfig *network.NetworkingConfig, containerName string) (container.ContainerCreateCreatedBody, error) {
	fake.containerCreateMutex.Lock()
	fake.containerCreateArgsForCall = append(fake.containerCreateArgsForCall, struct {
		ctx              context.Context
		config           *container.Config
		hostConfig       *container.HostConfig
		networkingConfig *network.NetworkingConfig
		containerName    string
	}{ctx, config, hostConfig, networkingConfig, containerName})
	fake.recordInvocation("ContainerCreate", []interface{}{ctx, config, hostConfig, networkingConfig, containerName})
	fake.containerCreateMutex.Unlock()
	if fake.ContainerCreateStub != nil {
		return fake.ContainerCreateStub(ctx, config, hostConfig, networkingConfig, containerName)
	} else {
		return fake.containerCreateReturns.result1, fake.containerCreateReturns.result2
	}
}

func (fake *fakeDockerClient) ContainerCreateCallCount() int {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	return len(fake.containerCreateArgsForCall)
}

func (fake *fakeDockerClient) ContainerCreateArgsForCall(i int) (context.Context, *container.Config, *container.HostConfig, *network.NetworkingConfig, string) {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	return fake.containerCreateArgsForCall[i].ctx, fake.containerCreateArgsForCall[i].config, fake.containerCreateArgsForCall[i].hostConfig, fake.containerCreateArgsForCall[i].networkingConfig, fake.containerCreateArgsForCall[i].containerName
}

func (fake *fakeDockerClient) ContainerCreateReturns(result1 container.ContainerCreateCreatedBody, result2 error) {
	fake.ContainerCreateStub = nil
	fake.containerCreateReturns = struct {
		result1 container.ContainerCreateCreatedBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerInspect(ctx context.Context, containerID string) (types.ContainerJSON, error) {
	fake.containerInspectMutex.Lock()
	fake.containerInspectArgsForCall = append(fake.containerInspectArgsForCall, struct {
		ctx         context.Context
		containerID string
	}{ctx, containerID})
	fake.recordInvocation("ContainerInspect", []interface{}{ctx, containerID})
	fake.containerInspectMutex.Unlock()
	if fake.ContainerInspectStub != nil {
		return fake.ContainerInspectStub(ctx, containerID)
	} else {
		return fake.containerInspectReturns.result1, fake.containerInspectReturns.result2
	}
}

func (fake *fakeDockerClient) ContainerInspectCallCount() int {
	fake.containerInspectMutex.RLock()
	defer fake.containerInspectMutex.RUnlock()
	return len(fake.containerInspectArgsForCall)
}

func (fake *fakeDockerClient) ContainerInspectArgsForCall(i int) (context.Context, string) {
	fake.containerInspectMutex.RLock()
	defer fake.containerInspectMutex.RUnlock()
	return fake.containerInspectArgsForCall[i].ctx, fake.containerInspectArgsForCall[i].containerID
}

func (fake *fakeDockerClient) ContainerInspectReturns(result1 types.ContainerJSON, result2 error) {
	fake.ContainerInspectStub = nil
	fake.containerInspectReturns = struct {
		result1 types.ContainerJSON
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerLogs(ctx context.Context, container string, options types.ContainerLogsOptions) (io.ReadCloser, error) {
	fake.containerLogsMutex.Lock()
	fake.containerLogsArgsForCall = append(fake.containerLogsArgsForCall, struct {
		ctx       context.Context
		container string
		options   types.ContainerLogsOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerLogs", []interface{}{ctx, container, options})
	fake.containerLogsMutex.Unlock()
	if fake.ContainerLogsStub != nil {
		return fake.ContainerLogsStub(ctx, container, options)
	} else {
		return fake.containerLogsReturns.result1, fake.containerLogsReturns.result2
	}
}

func (fake *fakeDockerClient) ContainerLogsCallCount() int {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	return len(fake.containerLogsArgsForCall)
}

func (fake *fakeDockerClient) ContainerLogsArgsForCall(i int) (context.Context, string, types.ContainerLogsOptions) {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	return fake.containerLogsArgsForCall[i].ctx, fake.containerLogsArgsForCall[i].container, fake.containerLogsArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerLogsReturns(result1 io.ReadCloser, result2 error) {
	fake.ContainerLogsStub = nil
	fake.containerLogsReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerRemove(ctx context.Context, containerID string, options types.ContainerRemoveOptions) error {
	fake.containerRemoveMutex.Lock()
	fake.containerRemoveArgsForCall = append(fake.containerRemoveArgsForCall, struct {
		ctx         context.Context
		containerID string
		options     types.ContainerRemoveOptions
	}{ctx, containerID, options})
	fake.recordInvocation("ContainerRemove", []interface{}{ctx, containerID, options})
	fake.containerRemoveMutex.Unlock()
	if fake.ContainerRemoveStub != nil {
		return fake.ContainerRemoveStub(ctx, containerID, options)
	} else {
		return fake.containerRemoveReturns.result1
	}
}

func (fake *fakeDockerClient) ContainerRemoveCallCount() int {
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	return len(fake.containerRemoveArgsForCall)
}

func (fake *fakeDockerClient) ContainerRemoveArgsForCall(i int) (context.Context, string, types.ContainerRemoveOptions) {
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	return fake.containerRemoveArgsForCall[i].ctx, fake.containerRemoveArgsForCall[i].containerID, fake.containerRemoveArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerRemoveReturns(result1 error) {
	fake.ContainerRemoveStub = nil
	fake.containerRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerStart(ctx context.Context, containerID string, options types.ContainerStartOptions) error {
	fake.containerStartMutex.Lock()
	fake.containerStartArgsForCall = append(fake.containerStartArgsForCall, struct {
		ctx         context.Context
		containerID string
		options     types.ContainerStartOptions
	}{ctx, containerID, options})
	fake.recordInvocation("ContainerStart", []interface{}{ctx, containerID, options})
	fake.containerStartMutex.Unlock()
	if fake.ContainerStartStub != nil {
		return fake.ContainerStartStub(ctx, containerID, options)
	} else {
		return fake.containerStartReturns.result1
	}
}

func (fake *fakeDockerClient) ContainerStartCallCount() int {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	return len(fake.containerStartArgsForCall)
}

func (fake *fakeDockerClient) ContainerStartArgsForCall(i int) (context.Context, string, types.ContainerStartOptions) {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	return fake.containerStartArgsForCall[i].ctx, fake.containerStartArgsForCall[i].containerID, fake.containerStartArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerStartReturns(result1 error) {
	fake.ContainerStartStub = nil
	fake.containerStartReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerWait(ctx context.Context, containerID string) (int64, error) {
	fake.containerWaitMutex.Lock()
	fake.containerWaitArgsForCall = append(fake.containerWaitArgsForCall, struct {
		ctx         context.Context
		containerID string
	}{ctx, containerID})
	fake.recordInvocation("ContainerWait", []interface{}{ctx, containerID})
	fake.containerWaitMutex.Unlock()
	if fake.ContainerWaitStub != nil {
		return fake.ContainerWaitStub(ctx, containerID)
	} else {
		return fake.containerWaitReturns.result1, fake.containerWaitReturns.result2
	}
}

func (fake *fakeDockerClient) ContainerWaitCallCount() int {
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	return len(fake.containerWaitArgsForCall)
}

func (fake *fakeDockerClient) ContainerWaitArgsForCall(i int) (context.Context, string) {
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	return fake.containerWaitArgsForCall[i].ctx, fake.containerWaitArgsForCall[i].containerID
}

func (fake *fakeDockerClient) ContainerWaitReturns(result1 int64, result2 error) {
	fake.ContainerWaitStub = nil
	fake.containerWaitReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagePull(ctx context.Context, ref string, options types.ImagePullOptions) (io.ReadCloser, error) {
	fake.imagePullMutex.Lock()
	fake.imagePullArgsForCall = append(fake.imagePullArgsForCall, struct {
		ctx     context.Context
		ref     string
		options types.ImagePullOptions
	}{ctx, ref, options})
	fake.recordInvocation("ImagePull", []interface{}{ctx, ref, options})
	fake.imagePullMutex.Unlock()
	if fake.ImagePullStub != nil {
		return fake.ImagePullStub(ctx, ref, options)
	} else {
		return fake.imagePullReturns.result1, fake.imagePullReturns.result2
	}
}

func (fake *fakeDockerClient) ImagePullCallCount() int {
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	return len(fake.imagePullArgsForCall)
}

func (fake *fakeDockerClient) ImagePullArgsForCall(i int) (context.Context, string, types.ImagePullOptions) {
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	return fake.imagePullArgsForCall[i].ctx, fake.imagePullArgsForCall[i].ref, fake.imagePullArgsForCall[i].options
}

func (fake *fakeDockerClient) ImagePullReturns(result1 io.ReadCloser, result2 error) {
	fake.ImagePullStub = nil
	fake.imagePullReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	fake.containerInspectMutex.RLock()
	defer fake.containerInspectMutex.RUnlock()
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	return fake.invocations
}

func (fake *fakeDockerClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
