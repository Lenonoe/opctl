// This file was generated by counterfeiter
package fake

import (
	"sync"

	"github.com/opspec-io/engine/pkg/containerengine"
	"github.com/opspec-io/engine/util/eventbus"
	"github.com/opspec-io/sdk-golang/pkg/model"
)

type ContainerEngine struct {
	StartContainerStub        func(cmd []string, env []*model.ContainerInstanceEnvEntry, fs []*model.ContainerInstanceFsEntry, image string, net []*model.ContainerInstanceNetEntry, workDir string, containerId string, eventPublisher eventbus.EventPublisher, opGraphId string) (err error)
	startContainerMutex       sync.RWMutex
	startContainerArgsForCall []struct {
		cmd            []string
		env            []*model.ContainerInstanceEnvEntry
		fs             []*model.ContainerInstanceFsEntry
		image          string
		net            []*model.ContainerInstanceNetEntry
		workDir        string
		containerId    string
		eventPublisher eventbus.EventPublisher
		opGraphId      string
	}
	startContainerReturns struct {
		result1 error
	}
	DeleteContainerIfExistsStub        func(containerId string)
	deleteContainerIfExistsMutex       sync.RWMutex
	deleteContainerIfExistsArgsForCall []struct {
		containerId string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ContainerEngine) StartContainer(cmd []string, env []*model.ContainerInstanceEnvEntry, fs []*model.ContainerInstanceFsEntry, image string, net []*model.ContainerInstanceNetEntry, workDir string, containerId string, eventPublisher eventbus.EventPublisher, opGraphId string) (err error) {
	var cmdCopy []string
	if cmd != nil {
		cmdCopy = make([]string, len(cmd))
		copy(cmdCopy, cmd)
	}
	var envCopy []*model.ContainerInstanceEnvEntry
	if env != nil {
		envCopy = make([]*model.ContainerInstanceEnvEntry, len(env))
		copy(envCopy, env)
	}
	var fsCopy []*model.ContainerInstanceFsEntry
	if fs != nil {
		fsCopy = make([]*model.ContainerInstanceFsEntry, len(fs))
		copy(fsCopy, fs)
	}
	var netCopy []*model.ContainerInstanceNetEntry
	if net != nil {
		netCopy = make([]*model.ContainerInstanceNetEntry, len(net))
		copy(netCopy, net)
	}
	fake.startContainerMutex.Lock()
	fake.startContainerArgsForCall = append(fake.startContainerArgsForCall, struct {
		cmd            []string
		env            []*model.ContainerInstanceEnvEntry
		fs             []*model.ContainerInstanceFsEntry
		image          string
		net            []*model.ContainerInstanceNetEntry
		workDir        string
		containerId    string
		eventPublisher eventbus.EventPublisher
		opGraphId      string
	}{cmdCopy, envCopy, fsCopy, image, netCopy, workDir, containerId, eventPublisher, opGraphId})
	fake.recordInvocation("StartContainer", []interface{}{cmdCopy, envCopy, fsCopy, image, netCopy, workDir, containerId, eventPublisher, opGraphId})
	fake.startContainerMutex.Unlock()
	if fake.StartContainerStub != nil {
		return fake.StartContainerStub(cmd, env, fs, image, net, workDir, containerId, eventPublisher, opGraphId)
	} else {
		return fake.startContainerReturns.result1
	}
}

func (fake *ContainerEngine) StartContainerCallCount() int {
	fake.startContainerMutex.RLock()
	defer fake.startContainerMutex.RUnlock()
	return len(fake.startContainerArgsForCall)
}

func (fake *ContainerEngine) StartContainerArgsForCall(i int) ([]string, []*model.ContainerInstanceEnvEntry, []*model.ContainerInstanceFsEntry, string, []*model.ContainerInstanceNetEntry, string, string, eventbus.EventPublisher, string) {
	fake.startContainerMutex.RLock()
	defer fake.startContainerMutex.RUnlock()
	return fake.startContainerArgsForCall[i].cmd, fake.startContainerArgsForCall[i].env, fake.startContainerArgsForCall[i].fs, fake.startContainerArgsForCall[i].image, fake.startContainerArgsForCall[i].net, fake.startContainerArgsForCall[i].workDir, fake.startContainerArgsForCall[i].containerId, fake.startContainerArgsForCall[i].eventPublisher, fake.startContainerArgsForCall[i].opGraphId
}

func (fake *ContainerEngine) StartContainerReturns(result1 error) {
	fake.StartContainerStub = nil
	fake.startContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *ContainerEngine) DeleteContainerIfExists(containerId string) {
	fake.deleteContainerIfExistsMutex.Lock()
	fake.deleteContainerIfExistsArgsForCall = append(fake.deleteContainerIfExistsArgsForCall, struct {
		containerId string
	}{containerId})
	fake.recordInvocation("DeleteContainerIfExists", []interface{}{containerId})
	fake.deleteContainerIfExistsMutex.Unlock()
	if fake.DeleteContainerIfExistsStub != nil {
		fake.DeleteContainerIfExistsStub(containerId)
	}
}

func (fake *ContainerEngine) DeleteContainerIfExistsCallCount() int {
	fake.deleteContainerIfExistsMutex.RLock()
	defer fake.deleteContainerIfExistsMutex.RUnlock()
	return len(fake.deleteContainerIfExistsArgsForCall)
}

func (fake *ContainerEngine) DeleteContainerIfExistsArgsForCall(i int) string {
	fake.deleteContainerIfExistsMutex.RLock()
	defer fake.deleteContainerIfExistsMutex.RUnlock()
	return fake.deleteContainerIfExistsArgsForCall[i].containerId
}

func (fake *ContainerEngine) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.startContainerMutex.RLock()
	defer fake.startContainerMutex.RUnlock()
	fake.deleteContainerIfExistsMutex.RLock()
	defer fake.deleteContainerIfExistsMutex.RUnlock()
	return fake.invocations
}

func (fake *ContainerEngine) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ containerengine.ContainerEngine = new(ContainerEngine)
