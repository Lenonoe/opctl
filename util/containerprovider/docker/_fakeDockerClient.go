// Code generated by counterfeiter. DO NOT EDIT.
package docker

import (
	"io"
	"sync"

	"github.com/docker/docker/api/types"
	containerPkg "github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/network"
	"golang.org/x/net/context"
)

type fakeDockerClient struct {
	ContainerCreateStub        func(ctx context.Context, config *containerPkg.Config, hostConfig *containerPkg.HostConfig, networkingConfig *network.NetworkingConfig, containerName string) (containerPkg.ContainerCreateCreatedBody, error)
	containerCreateMutex       sync.RWMutex
	containerCreateArgsForCall []struct {
		ctx              context.Context
		config           *containerPkg.Config
		hostConfig       *containerPkg.HostConfig
		networkingConfig *network.NetworkingConfig
		containerName    string
	}
	containerCreateReturns struct {
		result1 containerPkg.ContainerCreateCreatedBody
		result2 error
	}
	containerCreateReturnsOnCall map[int]struct {
		result1 containerPkg.ContainerCreateCreatedBody
		result2 error
	}
	ContainerKillStub        func(ctx context.Context, container, signal string) error
	containerKillMutex       sync.RWMutex
	containerKillArgsForCall []struct {
		ctx       context.Context
		container string
		signal    string
	}
	containerKillReturns struct {
		result1 error
	}
	containerKillReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerLogsStub        func(ctx context.Context, container string, options types.ContainerLogsOptions) (io.ReadCloser, error)
	containerLogsMutex       sync.RWMutex
	containerLogsArgsForCall []struct {
		ctx       context.Context
		container string
		options   types.ContainerLogsOptions
	}
	containerLogsReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	containerLogsReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ContainerRemoveStub        func(ctx context.Context, container string, options types.ContainerRemoveOptions) error
	containerRemoveMutex       sync.RWMutex
	containerRemoveArgsForCall []struct {
		ctx       context.Context
		container string
		options   types.ContainerRemoveOptions
	}
	containerRemoveReturns struct {
		result1 error
	}
	containerRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerStartStub        func(ctx context.Context, container string, options types.ContainerStartOptions) error
	containerStartMutex       sync.RWMutex
	containerStartArgsForCall []struct {
		ctx       context.Context
		container string
		options   types.ContainerStartOptions
	}
	containerStartReturns struct {
		result1 error
	}
	containerStartReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerWaitStub        func(ctx context.Context, container string, condition containerPkg.WaitCondition) (<-chan containerPkg.ContainerWaitOKBody, <-chan error)
	containerWaitMutex       sync.RWMutex
	containerWaitArgsForCall []struct {
		ctx       context.Context
		container string
		condition containerPkg.WaitCondition
	}
	containerWaitReturns struct {
		result1 <-chan containerPkg.ContainerWaitOKBody
		result2 <-chan error
	}
	containerWaitReturnsOnCall map[int]struct {
		result1 <-chan containerPkg.ContainerWaitOKBody
		result2 <-chan error
	}
	ImagePullStub        func(ctx context.Context, ref string, options types.ImagePullOptions) (io.ReadCloser, error)
	imagePullMutex       sync.RWMutex
	imagePullArgsForCall []struct {
		ctx     context.Context
		ref     string
		options types.ImagePullOptions
	}
	imagePullReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imagePullReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	NetworkCreateStub        func(ctx context.Context, name string, options types.NetworkCreate) (types.NetworkCreateResponse, error)
	networkCreateMutex       sync.RWMutex
	networkCreateArgsForCall []struct {
		ctx     context.Context
		name    string
		options types.NetworkCreate
	}
	networkCreateReturns struct {
		result1 types.NetworkCreateResponse
		result2 error
	}
	networkCreateReturnsOnCall map[int]struct {
		result1 types.NetworkCreateResponse
		result2 error
	}
	NetworkInspectStub        func(ctx context.Context, networkID string, options types.NetworkInspectOptions) (types.NetworkResource, error)
	networkInspectMutex       sync.RWMutex
	networkInspectArgsForCall []struct {
		ctx       context.Context
		networkID string
		options   types.NetworkInspectOptions
	}
	networkInspectReturns struct {
		result1 types.NetworkResource
		result2 error
	}
	networkInspectReturnsOnCall map[int]struct {
		result1 types.NetworkResource
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *fakeDockerClient) ContainerCreate(ctx context.Context, config *containerPkg.Config, hostConfig *containerPkg.HostConfig, networkingConfig *network.NetworkingConfig, containerName string) (containerPkg.ContainerCreateCreatedBody, error) {
	fake.containerCreateMutex.Lock()
	ret, specificReturn := fake.containerCreateReturnsOnCall[len(fake.containerCreateArgsForCall)]
	fake.containerCreateArgsForCall = append(fake.containerCreateArgsForCall, struct {
		ctx              context.Context
		config           *containerPkg.Config
		hostConfig       *containerPkg.HostConfig
		networkingConfig *network.NetworkingConfig
		containerName    string
	}{ctx, config, hostConfig, networkingConfig, containerName})
	fake.recordInvocation("ContainerCreate", []interface{}{ctx, config, hostConfig, networkingConfig, containerName})
	fake.containerCreateMutex.Unlock()
	if fake.ContainerCreateStub != nil {
		return fake.ContainerCreateStub(ctx, config, hostConfig, networkingConfig, containerName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerCreateReturns.result1, fake.containerCreateReturns.result2
}

func (fake *fakeDockerClient) ContainerCreateCallCount() int {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	return len(fake.containerCreateArgsForCall)
}

func (fake *fakeDockerClient) ContainerCreateArgsForCall(i int) (context.Context, *containerPkg.Config, *containerPkg.HostConfig, *network.NetworkingConfig, string) {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	return fake.containerCreateArgsForCall[i].ctx, fake.containerCreateArgsForCall[i].config, fake.containerCreateArgsForCall[i].hostConfig, fake.containerCreateArgsForCall[i].networkingConfig, fake.containerCreateArgsForCall[i].containerName
}

func (fake *fakeDockerClient) ContainerCreateReturns(result1 containerPkg.ContainerCreateCreatedBody, result2 error) {
	fake.ContainerCreateStub = nil
	fake.containerCreateReturns = struct {
		result1 containerPkg.ContainerCreateCreatedBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerCreateReturnsOnCall(i int, result1 containerPkg.ContainerCreateCreatedBody, result2 error) {
	fake.ContainerCreateStub = nil
	if fake.containerCreateReturnsOnCall == nil {
		fake.containerCreateReturnsOnCall = make(map[int]struct {
			result1 containerPkg.ContainerCreateCreatedBody
			result2 error
		})
	}
	fake.containerCreateReturnsOnCall[i] = struct {
		result1 containerPkg.ContainerCreateCreatedBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerKill(ctx context.Context, container string, signal string) error {
	fake.containerKillMutex.Lock()
	ret, specificReturn := fake.containerKillReturnsOnCall[len(fake.containerKillArgsForCall)]
	fake.containerKillArgsForCall = append(fake.containerKillArgsForCall, struct {
		ctx       context.Context
		container string
		signal    string
	}{ctx, container, signal})
	fake.recordInvocation("ContainerKill", []interface{}{ctx, container, signal})
	fake.containerKillMutex.Unlock()
	if fake.ContainerKillStub != nil {
		return fake.ContainerKillStub(ctx, container, signal)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerKillReturns.result1
}

func (fake *fakeDockerClient) ContainerKillCallCount() int {
	fake.containerKillMutex.RLock()
	defer fake.containerKillMutex.RUnlock()
	return len(fake.containerKillArgsForCall)
}

func (fake *fakeDockerClient) ContainerKillArgsForCall(i int) (context.Context, string, string) {
	fake.containerKillMutex.RLock()
	defer fake.containerKillMutex.RUnlock()
	return fake.containerKillArgsForCall[i].ctx, fake.containerKillArgsForCall[i].container, fake.containerKillArgsForCall[i].signal
}

func (fake *fakeDockerClient) ContainerKillReturns(result1 error) {
	fake.ContainerKillStub = nil
	fake.containerKillReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerKillReturnsOnCall(i int, result1 error) {
	fake.ContainerKillStub = nil
	if fake.containerKillReturnsOnCall == nil {
		fake.containerKillReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerKillReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerLogs(ctx context.Context, container string, options types.ContainerLogsOptions) (io.ReadCloser, error) {
	fake.containerLogsMutex.Lock()
	ret, specificReturn := fake.containerLogsReturnsOnCall[len(fake.containerLogsArgsForCall)]
	fake.containerLogsArgsForCall = append(fake.containerLogsArgsForCall, struct {
		ctx       context.Context
		container string
		options   types.ContainerLogsOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerLogs", []interface{}{ctx, container, options})
	fake.containerLogsMutex.Unlock()
	if fake.ContainerLogsStub != nil {
		return fake.ContainerLogsStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerLogsReturns.result1, fake.containerLogsReturns.result2
}

func (fake *fakeDockerClient) ContainerLogsCallCount() int {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	return len(fake.containerLogsArgsForCall)
}

func (fake *fakeDockerClient) ContainerLogsArgsForCall(i int) (context.Context, string, types.ContainerLogsOptions) {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	return fake.containerLogsArgsForCall[i].ctx, fake.containerLogsArgsForCall[i].container, fake.containerLogsArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerLogsReturns(result1 io.ReadCloser, result2 error) {
	fake.ContainerLogsStub = nil
	fake.containerLogsReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerLogsReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ContainerLogsStub = nil
	if fake.containerLogsReturnsOnCall == nil {
		fake.containerLogsReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.containerLogsReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerRemove(ctx context.Context, container string, options types.ContainerRemoveOptions) error {
	fake.containerRemoveMutex.Lock()
	ret, specificReturn := fake.containerRemoveReturnsOnCall[len(fake.containerRemoveArgsForCall)]
	fake.containerRemoveArgsForCall = append(fake.containerRemoveArgsForCall, struct {
		ctx       context.Context
		container string
		options   types.ContainerRemoveOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerRemove", []interface{}{ctx, container, options})
	fake.containerRemoveMutex.Unlock()
	if fake.ContainerRemoveStub != nil {
		return fake.ContainerRemoveStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerRemoveReturns.result1
}

func (fake *fakeDockerClient) ContainerRemoveCallCount() int {
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	return len(fake.containerRemoveArgsForCall)
}

func (fake *fakeDockerClient) ContainerRemoveArgsForCall(i int) (context.Context, string, types.ContainerRemoveOptions) {
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	return fake.containerRemoveArgsForCall[i].ctx, fake.containerRemoveArgsForCall[i].container, fake.containerRemoveArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerRemoveReturns(result1 error) {
	fake.ContainerRemoveStub = nil
	fake.containerRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerRemoveReturnsOnCall(i int, result1 error) {
	fake.ContainerRemoveStub = nil
	if fake.containerRemoveReturnsOnCall == nil {
		fake.containerRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerStart(ctx context.Context, container string, options types.ContainerStartOptions) error {
	fake.containerStartMutex.Lock()
	ret, specificReturn := fake.containerStartReturnsOnCall[len(fake.containerStartArgsForCall)]
	fake.containerStartArgsForCall = append(fake.containerStartArgsForCall, struct {
		ctx       context.Context
		container string
		options   types.ContainerStartOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerStart", []interface{}{ctx, container, options})
	fake.containerStartMutex.Unlock()
	if fake.ContainerStartStub != nil {
		return fake.ContainerStartStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerStartReturns.result1
}

func (fake *fakeDockerClient) ContainerStartCallCount() int {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	return len(fake.containerStartArgsForCall)
}

func (fake *fakeDockerClient) ContainerStartArgsForCall(i int) (context.Context, string, types.ContainerStartOptions) {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	return fake.containerStartArgsForCall[i].ctx, fake.containerStartArgsForCall[i].container, fake.containerStartArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerStartReturns(result1 error) {
	fake.ContainerStartStub = nil
	fake.containerStartReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerStartReturnsOnCall(i int, result1 error) {
	fake.ContainerStartStub = nil
	if fake.containerStartReturnsOnCall == nil {
		fake.containerStartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerStartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerWait(ctx context.Context, container string, condition containerPkg.WaitCondition) (<-chan containerPkg.ContainerWaitOKBody, <-chan error) {
	fake.containerWaitMutex.Lock()
	ret, specificReturn := fake.containerWaitReturnsOnCall[len(fake.containerWaitArgsForCall)]
	fake.containerWaitArgsForCall = append(fake.containerWaitArgsForCall, struct {
		ctx       context.Context
		container string
		condition containerPkg.WaitCondition
	}{ctx, container, condition})
	fake.recordInvocation("ContainerWait", []interface{}{ctx, container, condition})
	fake.containerWaitMutex.Unlock()
	if fake.ContainerWaitStub != nil {
		return fake.ContainerWaitStub(ctx, container, condition)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerWaitReturns.result1, fake.containerWaitReturns.result2
}

func (fake *fakeDockerClient) ContainerWaitCallCount() int {
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	return len(fake.containerWaitArgsForCall)
}

func (fake *fakeDockerClient) ContainerWaitArgsForCall(i int) (context.Context, string, containerPkg.WaitCondition) {
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	return fake.containerWaitArgsForCall[i].ctx, fake.containerWaitArgsForCall[i].container, fake.containerWaitArgsForCall[i].condition
}

func (fake *fakeDockerClient) ContainerWaitReturns(result1 <-chan containerPkg.ContainerWaitOKBody, result2 <-chan error) {
	fake.ContainerWaitStub = nil
	fake.containerWaitReturns = struct {
		result1 <-chan containerPkg.ContainerWaitOKBody
		result2 <-chan error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerWaitReturnsOnCall(i int, result1 <-chan containerPkg.ContainerWaitOKBody, result2 <-chan error) {
	fake.ContainerWaitStub = nil
	if fake.containerWaitReturnsOnCall == nil {
		fake.containerWaitReturnsOnCall = make(map[int]struct {
			result1 <-chan containerPkg.ContainerWaitOKBody
			result2 <-chan error
		})
	}
	fake.containerWaitReturnsOnCall[i] = struct {
		result1 <-chan containerPkg.ContainerWaitOKBody
		result2 <-chan error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagePull(ctx context.Context, ref string, options types.ImagePullOptions) (io.ReadCloser, error) {
	fake.imagePullMutex.Lock()
	ret, specificReturn := fake.imagePullReturnsOnCall[len(fake.imagePullArgsForCall)]
	fake.imagePullArgsForCall = append(fake.imagePullArgsForCall, struct {
		ctx     context.Context
		ref     string
		options types.ImagePullOptions
	}{ctx, ref, options})
	fake.recordInvocation("ImagePull", []interface{}{ctx, ref, options})
	fake.imagePullMutex.Unlock()
	if fake.ImagePullStub != nil {
		return fake.ImagePullStub(ctx, ref, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imagePullReturns.result1, fake.imagePullReturns.result2
}

func (fake *fakeDockerClient) ImagePullCallCount() int {
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	return len(fake.imagePullArgsForCall)
}

func (fake *fakeDockerClient) ImagePullArgsForCall(i int) (context.Context, string, types.ImagePullOptions) {
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	return fake.imagePullArgsForCall[i].ctx, fake.imagePullArgsForCall[i].ref, fake.imagePullArgsForCall[i].options
}

func (fake *fakeDockerClient) ImagePullReturns(result1 io.ReadCloser, result2 error) {
	fake.ImagePullStub = nil
	fake.imagePullReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagePullReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ImagePullStub = nil
	if fake.imagePullReturnsOnCall == nil {
		fake.imagePullReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imagePullReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkCreate(ctx context.Context, name string, options types.NetworkCreate) (types.NetworkCreateResponse, error) {
	fake.networkCreateMutex.Lock()
	ret, specificReturn := fake.networkCreateReturnsOnCall[len(fake.networkCreateArgsForCall)]
	fake.networkCreateArgsForCall = append(fake.networkCreateArgsForCall, struct {
		ctx     context.Context
		name    string
		options types.NetworkCreate
	}{ctx, name, options})
	fake.recordInvocation("NetworkCreate", []interface{}{ctx, name, options})
	fake.networkCreateMutex.Unlock()
	if fake.NetworkCreateStub != nil {
		return fake.NetworkCreateStub(ctx, name, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.networkCreateReturns.result1, fake.networkCreateReturns.result2
}

func (fake *fakeDockerClient) NetworkCreateCallCount() int {
	fake.networkCreateMutex.RLock()
	defer fake.networkCreateMutex.RUnlock()
	return len(fake.networkCreateArgsForCall)
}

func (fake *fakeDockerClient) NetworkCreateArgsForCall(i int) (context.Context, string, types.NetworkCreate) {
	fake.networkCreateMutex.RLock()
	defer fake.networkCreateMutex.RUnlock()
	return fake.networkCreateArgsForCall[i].ctx, fake.networkCreateArgsForCall[i].name, fake.networkCreateArgsForCall[i].options
}

func (fake *fakeDockerClient) NetworkCreateReturns(result1 types.NetworkCreateResponse, result2 error) {
	fake.NetworkCreateStub = nil
	fake.networkCreateReturns = struct {
		result1 types.NetworkCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkCreateReturnsOnCall(i int, result1 types.NetworkCreateResponse, result2 error) {
	fake.NetworkCreateStub = nil
	if fake.networkCreateReturnsOnCall == nil {
		fake.networkCreateReturnsOnCall = make(map[int]struct {
			result1 types.NetworkCreateResponse
			result2 error
		})
	}
	fake.networkCreateReturnsOnCall[i] = struct {
		result1 types.NetworkCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkInspect(ctx context.Context, networkID string, options types.NetworkInspectOptions) (types.NetworkResource, error) {
	fake.networkInspectMutex.Lock()
	ret, specificReturn := fake.networkInspectReturnsOnCall[len(fake.networkInspectArgsForCall)]
	fake.networkInspectArgsForCall = append(fake.networkInspectArgsForCall, struct {
		ctx       context.Context
		networkID string
		options   types.NetworkInspectOptions
	}{ctx, networkID, options})
	fake.recordInvocation("NetworkInspect", []interface{}{ctx, networkID, options})
	fake.networkInspectMutex.Unlock()
	if fake.NetworkInspectStub != nil {
		return fake.NetworkInspectStub(ctx, networkID, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.networkInspectReturns.result1, fake.networkInspectReturns.result2
}

func (fake *fakeDockerClient) NetworkInspectCallCount() int {
	fake.networkInspectMutex.RLock()
	defer fake.networkInspectMutex.RUnlock()
	return len(fake.networkInspectArgsForCall)
}

func (fake *fakeDockerClient) NetworkInspectArgsForCall(i int) (context.Context, string, types.NetworkInspectOptions) {
	fake.networkInspectMutex.RLock()
	defer fake.networkInspectMutex.RUnlock()
	return fake.networkInspectArgsForCall[i].ctx, fake.networkInspectArgsForCall[i].networkID, fake.networkInspectArgsForCall[i].options
}

func (fake *fakeDockerClient) NetworkInspectReturns(result1 types.NetworkResource, result2 error) {
	fake.NetworkInspectStub = nil
	fake.networkInspectReturns = struct {
		result1 types.NetworkResource
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkInspectReturnsOnCall(i int, result1 types.NetworkResource, result2 error) {
	fake.NetworkInspectStub = nil
	if fake.networkInspectReturnsOnCall == nil {
		fake.networkInspectReturnsOnCall = make(map[int]struct {
			result1 types.NetworkResource
			result2 error
		})
	}
	fake.networkInspectReturnsOnCall[i] = struct {
		result1 types.NetworkResource
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	fake.containerKillMutex.RLock()
	defer fake.containerKillMutex.RUnlock()
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	fake.networkCreateMutex.RLock()
	defer fake.networkCreateMutex.RUnlock()
	fake.networkInspectMutex.RLock()
	defer fake.networkInspectMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *fakeDockerClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
