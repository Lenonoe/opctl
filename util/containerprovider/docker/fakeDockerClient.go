// This file was generated by counterfeiter
package docker

import (
	"io"
	"sync"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/network"
	"github.com/docker/docker/api/types/registry"
	"golang.org/x/net/context"
)

type fakeDockerClient struct {
	NetworkConnectStub        func(ctx context.Context, networkID, containerID string, config *network.EndpointSettings) error
	networkConnectMutex       sync.RWMutex
	networkConnectArgsForCall []struct {
		ctx         context.Context
		networkID   string
		containerID string
		config      *network.EndpointSettings
	}
	networkConnectReturns struct {
		result1 error
	}
	networkConnectReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerCreateStub        func(ctx context.Context, config *container.Config, hostConfig *container.HostConfig, networkingConfig *network.NetworkingConfig, containerName string) (container.ContainerCreateCreatedBody, error)
	containerCreateMutex       sync.RWMutex
	containerCreateArgsForCall []struct {
		ctx              context.Context
		config           *container.Config
		hostConfig       *container.HostConfig
		networkingConfig *network.NetworkingConfig
		containerName    string
	}
	containerCreateReturns struct {
		result1 container.ContainerCreateCreatedBody
		result2 error
	}
	containerCreateReturnsOnCall map[int]struct {
		result1 container.ContainerCreateCreatedBody
		result2 error
	}
	ContainerLogsStub        func(ctx context.Context, container string, options types.ContainerLogsOptions) (io.ReadCloser, error)
	containerLogsMutex       sync.RWMutex
	containerLogsArgsForCall []struct {
		ctx       context.Context
		container string
		options   types.ContainerLogsOptions
	}
	containerLogsReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	containerLogsReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ContainerRemoveStub        func(ctx context.Context, containerID string, options types.ContainerRemoveOptions) error
	containerRemoveMutex       sync.RWMutex
	containerRemoveArgsForCall []struct {
		ctx         context.Context
		containerID string
		options     types.ContainerRemoveOptions
	}
	containerRemoveReturns struct {
		result1 error
	}
	containerRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerStartStub        func(ctx context.Context, containerID string, options types.ContainerStartOptions) error
	containerStartMutex       sync.RWMutex
	containerStartArgsForCall []struct {
		ctx         context.Context
		containerID string
		options     types.ContainerStartOptions
	}
	containerStartReturns struct {
		result1 error
	}
	containerStartReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerWaitStub        func(ctx context.Context, containerID string) (int64, error)
	containerWaitMutex       sync.RWMutex
	containerWaitArgsForCall []struct {
		ctx         context.Context
		containerID string
	}
	containerWaitReturns struct {
		result1 int64
		result2 error
	}
	containerWaitReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	ImagePullStub        func(ctx context.Context, ref string, options types.ImagePullOptions) (io.ReadCloser, error)
	imagePullMutex       sync.RWMutex
	imagePullArgsForCall []struct {
		ctx     context.Context
		ref     string
		options types.ImagePullOptions
	}
	imagePullReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imagePullReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	NetworkCreateStub        func(ctx context.Context, name string, options types.NetworkCreate) (types.NetworkCreateResponse, error)
	networkCreateMutex       sync.RWMutex
	networkCreateArgsForCall []struct {
		ctx     context.Context
		name    string
		options types.NetworkCreate
	}
	networkCreateReturns struct {
		result1 types.NetworkCreateResponse
		result2 error
	}
	networkCreateReturnsOnCall map[int]struct {
		result1 types.NetworkCreateResponse
		result2 error
	}
	NetworkRemoveStub        func(ctx context.Context, networkID string) error
	networkRemoveMutex       sync.RWMutex
	networkRemoveArgsForCall []struct {
		ctx       context.Context
		networkID string
	}
	networkRemoveReturns struct {
		result1 error
	}
	networkRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	RegistryLoginStub        func(ctx context.Context, auth types.AuthConfig) (registry.AuthenticateOKBody, error)
	registryLoginMutex       sync.RWMutex
	registryLoginArgsForCall []struct {
		ctx  context.Context
		auth types.AuthConfig
	}
	registryLoginReturns struct {
		result1 registry.AuthenticateOKBody
		result2 error
	}
	registryLoginReturnsOnCall map[int]struct {
		result1 registry.AuthenticateOKBody
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *fakeDockerClient) NetworkConnect(ctx context.Context, networkID string, containerID string, config *network.EndpointSettings) error {
	fake.networkConnectMutex.Lock()
	ret, specificReturn := fake.networkConnectReturnsOnCall[len(fake.networkConnectArgsForCall)]
	fake.networkConnectArgsForCall = append(fake.networkConnectArgsForCall, struct {
		ctx         context.Context
		networkID   string
		containerID string
		config      *network.EndpointSettings
	}{ctx, networkID, containerID, config})
	fake.recordInvocation("NetworkConnect", []interface{}{ctx, networkID, containerID, config})
	fake.networkConnectMutex.Unlock()
	if fake.NetworkConnectStub != nil {
		return fake.NetworkConnectStub(ctx, networkID, containerID, config)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.networkConnectReturns.result1
}

func (fake *fakeDockerClient) NetworkConnectCallCount() int {
	fake.networkConnectMutex.RLock()
	defer fake.networkConnectMutex.RUnlock()
	return len(fake.networkConnectArgsForCall)
}

func (fake *fakeDockerClient) NetworkConnectArgsForCall(i int) (context.Context, string, string, *network.EndpointSettings) {
	fake.networkConnectMutex.RLock()
	defer fake.networkConnectMutex.RUnlock()
	return fake.networkConnectArgsForCall[i].ctx, fake.networkConnectArgsForCall[i].networkID, fake.networkConnectArgsForCall[i].containerID, fake.networkConnectArgsForCall[i].config
}

func (fake *fakeDockerClient) NetworkConnectReturns(result1 error) {
	fake.NetworkConnectStub = nil
	fake.networkConnectReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworkConnectReturnsOnCall(i int, result1 error) {
	fake.NetworkConnectStub = nil
	if fake.networkConnectReturnsOnCall == nil {
		fake.networkConnectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.networkConnectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerCreate(ctx context.Context, config *container.Config, hostConfig *container.HostConfig, networkingConfig *network.NetworkingConfig, containerName string) (container.ContainerCreateCreatedBody, error) {
	fake.containerCreateMutex.Lock()
	ret, specificReturn := fake.containerCreateReturnsOnCall[len(fake.containerCreateArgsForCall)]
	fake.containerCreateArgsForCall = append(fake.containerCreateArgsForCall, struct {
		ctx              context.Context
		config           *container.Config
		hostConfig       *container.HostConfig
		networkingConfig *network.NetworkingConfig
		containerName    string
	}{ctx, config, hostConfig, networkingConfig, containerName})
	fake.recordInvocation("ContainerCreate", []interface{}{ctx, config, hostConfig, networkingConfig, containerName})
	fake.containerCreateMutex.Unlock()
	if fake.ContainerCreateStub != nil {
		return fake.ContainerCreateStub(ctx, config, hostConfig, networkingConfig, containerName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerCreateReturns.result1, fake.containerCreateReturns.result2
}

func (fake *fakeDockerClient) ContainerCreateCallCount() int {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	return len(fake.containerCreateArgsForCall)
}

func (fake *fakeDockerClient) ContainerCreateArgsForCall(i int) (context.Context, *container.Config, *container.HostConfig, *network.NetworkingConfig, string) {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	return fake.containerCreateArgsForCall[i].ctx, fake.containerCreateArgsForCall[i].config, fake.containerCreateArgsForCall[i].hostConfig, fake.containerCreateArgsForCall[i].networkingConfig, fake.containerCreateArgsForCall[i].containerName
}

func (fake *fakeDockerClient) ContainerCreateReturns(result1 container.ContainerCreateCreatedBody, result2 error) {
	fake.ContainerCreateStub = nil
	fake.containerCreateReturns = struct {
		result1 container.ContainerCreateCreatedBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerCreateReturnsOnCall(i int, result1 container.ContainerCreateCreatedBody, result2 error) {
	fake.ContainerCreateStub = nil
	if fake.containerCreateReturnsOnCall == nil {
		fake.containerCreateReturnsOnCall = make(map[int]struct {
			result1 container.ContainerCreateCreatedBody
			result2 error
		})
	}
	fake.containerCreateReturnsOnCall[i] = struct {
		result1 container.ContainerCreateCreatedBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerLogs(ctx context.Context, container string, options types.ContainerLogsOptions) (io.ReadCloser, error) {
	fake.containerLogsMutex.Lock()
	ret, specificReturn := fake.containerLogsReturnsOnCall[len(fake.containerLogsArgsForCall)]
	fake.containerLogsArgsForCall = append(fake.containerLogsArgsForCall, struct {
		ctx       context.Context
		container string
		options   types.ContainerLogsOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerLogs", []interface{}{ctx, container, options})
	fake.containerLogsMutex.Unlock()
	if fake.ContainerLogsStub != nil {
		return fake.ContainerLogsStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerLogsReturns.result1, fake.containerLogsReturns.result2
}

func (fake *fakeDockerClient) ContainerLogsCallCount() int {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	return len(fake.containerLogsArgsForCall)
}

func (fake *fakeDockerClient) ContainerLogsArgsForCall(i int) (context.Context, string, types.ContainerLogsOptions) {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	return fake.containerLogsArgsForCall[i].ctx, fake.containerLogsArgsForCall[i].container, fake.containerLogsArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerLogsReturns(result1 io.ReadCloser, result2 error) {
	fake.ContainerLogsStub = nil
	fake.containerLogsReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerLogsReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ContainerLogsStub = nil
	if fake.containerLogsReturnsOnCall == nil {
		fake.containerLogsReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.containerLogsReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerRemove(ctx context.Context, containerID string, options types.ContainerRemoveOptions) error {
	fake.containerRemoveMutex.Lock()
	ret, specificReturn := fake.containerRemoveReturnsOnCall[len(fake.containerRemoveArgsForCall)]
	fake.containerRemoveArgsForCall = append(fake.containerRemoveArgsForCall, struct {
		ctx         context.Context
		containerID string
		options     types.ContainerRemoveOptions
	}{ctx, containerID, options})
	fake.recordInvocation("ContainerRemove", []interface{}{ctx, containerID, options})
	fake.containerRemoveMutex.Unlock()
	if fake.ContainerRemoveStub != nil {
		return fake.ContainerRemoveStub(ctx, containerID, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerRemoveReturns.result1
}

func (fake *fakeDockerClient) ContainerRemoveCallCount() int {
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	return len(fake.containerRemoveArgsForCall)
}

func (fake *fakeDockerClient) ContainerRemoveArgsForCall(i int) (context.Context, string, types.ContainerRemoveOptions) {
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	return fake.containerRemoveArgsForCall[i].ctx, fake.containerRemoveArgsForCall[i].containerID, fake.containerRemoveArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerRemoveReturns(result1 error) {
	fake.ContainerRemoveStub = nil
	fake.containerRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerRemoveReturnsOnCall(i int, result1 error) {
	fake.ContainerRemoveStub = nil
	if fake.containerRemoveReturnsOnCall == nil {
		fake.containerRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerStart(ctx context.Context, containerID string, options types.ContainerStartOptions) error {
	fake.containerStartMutex.Lock()
	ret, specificReturn := fake.containerStartReturnsOnCall[len(fake.containerStartArgsForCall)]
	fake.containerStartArgsForCall = append(fake.containerStartArgsForCall, struct {
		ctx         context.Context
		containerID string
		options     types.ContainerStartOptions
	}{ctx, containerID, options})
	fake.recordInvocation("ContainerStart", []interface{}{ctx, containerID, options})
	fake.containerStartMutex.Unlock()
	if fake.ContainerStartStub != nil {
		return fake.ContainerStartStub(ctx, containerID, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerStartReturns.result1
}

func (fake *fakeDockerClient) ContainerStartCallCount() int {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	return len(fake.containerStartArgsForCall)
}

func (fake *fakeDockerClient) ContainerStartArgsForCall(i int) (context.Context, string, types.ContainerStartOptions) {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	return fake.containerStartArgsForCall[i].ctx, fake.containerStartArgsForCall[i].containerID, fake.containerStartArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerStartReturns(result1 error) {
	fake.ContainerStartStub = nil
	fake.containerStartReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerStartReturnsOnCall(i int, result1 error) {
	fake.ContainerStartStub = nil
	if fake.containerStartReturnsOnCall == nil {
		fake.containerStartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerStartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerWait(ctx context.Context, containerID string) (int64, error) {
	fake.containerWaitMutex.Lock()
	ret, specificReturn := fake.containerWaitReturnsOnCall[len(fake.containerWaitArgsForCall)]
	fake.containerWaitArgsForCall = append(fake.containerWaitArgsForCall, struct {
		ctx         context.Context
		containerID string
	}{ctx, containerID})
	fake.recordInvocation("ContainerWait", []interface{}{ctx, containerID})
	fake.containerWaitMutex.Unlock()
	if fake.ContainerWaitStub != nil {
		return fake.ContainerWaitStub(ctx, containerID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerWaitReturns.result1, fake.containerWaitReturns.result2
}

func (fake *fakeDockerClient) ContainerWaitCallCount() int {
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	return len(fake.containerWaitArgsForCall)
}

func (fake *fakeDockerClient) ContainerWaitArgsForCall(i int) (context.Context, string) {
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	return fake.containerWaitArgsForCall[i].ctx, fake.containerWaitArgsForCall[i].containerID
}

func (fake *fakeDockerClient) ContainerWaitReturns(result1 int64, result2 error) {
	fake.ContainerWaitStub = nil
	fake.containerWaitReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerWaitReturnsOnCall(i int, result1 int64, result2 error) {
	fake.ContainerWaitStub = nil
	if fake.containerWaitReturnsOnCall == nil {
		fake.containerWaitReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.containerWaitReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagePull(ctx context.Context, ref string, options types.ImagePullOptions) (io.ReadCloser, error) {
	fake.imagePullMutex.Lock()
	ret, specificReturn := fake.imagePullReturnsOnCall[len(fake.imagePullArgsForCall)]
	fake.imagePullArgsForCall = append(fake.imagePullArgsForCall, struct {
		ctx     context.Context
		ref     string
		options types.ImagePullOptions
	}{ctx, ref, options})
	fake.recordInvocation("ImagePull", []interface{}{ctx, ref, options})
	fake.imagePullMutex.Unlock()
	if fake.ImagePullStub != nil {
		return fake.ImagePullStub(ctx, ref, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imagePullReturns.result1, fake.imagePullReturns.result2
}

func (fake *fakeDockerClient) ImagePullCallCount() int {
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	return len(fake.imagePullArgsForCall)
}

func (fake *fakeDockerClient) ImagePullArgsForCall(i int) (context.Context, string, types.ImagePullOptions) {
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	return fake.imagePullArgsForCall[i].ctx, fake.imagePullArgsForCall[i].ref, fake.imagePullArgsForCall[i].options
}

func (fake *fakeDockerClient) ImagePullReturns(result1 io.ReadCloser, result2 error) {
	fake.ImagePullStub = nil
	fake.imagePullReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagePullReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ImagePullStub = nil
	if fake.imagePullReturnsOnCall == nil {
		fake.imagePullReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imagePullReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkCreate(ctx context.Context, name string, options types.NetworkCreate) (types.NetworkCreateResponse, error) {
	fake.networkCreateMutex.Lock()
	ret, specificReturn := fake.networkCreateReturnsOnCall[len(fake.networkCreateArgsForCall)]
	fake.networkCreateArgsForCall = append(fake.networkCreateArgsForCall, struct {
		ctx     context.Context
		name    string
		options types.NetworkCreate
	}{ctx, name, options})
	fake.recordInvocation("NetworkCreate", []interface{}{ctx, name, options})
	fake.networkCreateMutex.Unlock()
	if fake.NetworkCreateStub != nil {
		return fake.NetworkCreateStub(ctx, name, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.networkCreateReturns.result1, fake.networkCreateReturns.result2
}

func (fake *fakeDockerClient) NetworkCreateCallCount() int {
	fake.networkCreateMutex.RLock()
	defer fake.networkCreateMutex.RUnlock()
	return len(fake.networkCreateArgsForCall)
}

func (fake *fakeDockerClient) NetworkCreateArgsForCall(i int) (context.Context, string, types.NetworkCreate) {
	fake.networkCreateMutex.RLock()
	defer fake.networkCreateMutex.RUnlock()
	return fake.networkCreateArgsForCall[i].ctx, fake.networkCreateArgsForCall[i].name, fake.networkCreateArgsForCall[i].options
}

func (fake *fakeDockerClient) NetworkCreateReturns(result1 types.NetworkCreateResponse, result2 error) {
	fake.NetworkCreateStub = nil
	fake.networkCreateReturns = struct {
		result1 types.NetworkCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkCreateReturnsOnCall(i int, result1 types.NetworkCreateResponse, result2 error) {
	fake.NetworkCreateStub = nil
	if fake.networkCreateReturnsOnCall == nil {
		fake.networkCreateReturnsOnCall = make(map[int]struct {
			result1 types.NetworkCreateResponse
			result2 error
		})
	}
	fake.networkCreateReturnsOnCall[i] = struct {
		result1 types.NetworkCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkRemove(ctx context.Context, networkID string) error {
	fake.networkRemoveMutex.Lock()
	ret, specificReturn := fake.networkRemoveReturnsOnCall[len(fake.networkRemoveArgsForCall)]
	fake.networkRemoveArgsForCall = append(fake.networkRemoveArgsForCall, struct {
		ctx       context.Context
		networkID string
	}{ctx, networkID})
	fake.recordInvocation("NetworkRemove", []interface{}{ctx, networkID})
	fake.networkRemoveMutex.Unlock()
	if fake.NetworkRemoveStub != nil {
		return fake.NetworkRemoveStub(ctx, networkID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.networkRemoveReturns.result1
}

func (fake *fakeDockerClient) NetworkRemoveCallCount() int {
	fake.networkRemoveMutex.RLock()
	defer fake.networkRemoveMutex.RUnlock()
	return len(fake.networkRemoveArgsForCall)
}

func (fake *fakeDockerClient) NetworkRemoveArgsForCall(i int) (context.Context, string) {
	fake.networkRemoveMutex.RLock()
	defer fake.networkRemoveMutex.RUnlock()
	return fake.networkRemoveArgsForCall[i].ctx, fake.networkRemoveArgsForCall[i].networkID
}

func (fake *fakeDockerClient) NetworkRemoveReturns(result1 error) {
	fake.NetworkRemoveStub = nil
	fake.networkRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworkRemoveReturnsOnCall(i int, result1 error) {
	fake.NetworkRemoveStub = nil
	if fake.networkRemoveReturnsOnCall == nil {
		fake.networkRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.networkRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) RegistryLogin(ctx context.Context, auth types.AuthConfig) (registry.AuthenticateOKBody, error) {
	fake.registryLoginMutex.Lock()
	ret, specificReturn := fake.registryLoginReturnsOnCall[len(fake.registryLoginArgsForCall)]
	fake.registryLoginArgsForCall = append(fake.registryLoginArgsForCall, struct {
		ctx  context.Context
		auth types.AuthConfig
	}{ctx, auth})
	fake.recordInvocation("RegistryLogin", []interface{}{ctx, auth})
	fake.registryLoginMutex.Unlock()
	if fake.RegistryLoginStub != nil {
		return fake.RegistryLoginStub(ctx, auth)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.registryLoginReturns.result1, fake.registryLoginReturns.result2
}

func (fake *fakeDockerClient) RegistryLoginCallCount() int {
	fake.registryLoginMutex.RLock()
	defer fake.registryLoginMutex.RUnlock()
	return len(fake.registryLoginArgsForCall)
}

func (fake *fakeDockerClient) RegistryLoginArgsForCall(i int) (context.Context, types.AuthConfig) {
	fake.registryLoginMutex.RLock()
	defer fake.registryLoginMutex.RUnlock()
	return fake.registryLoginArgsForCall[i].ctx, fake.registryLoginArgsForCall[i].auth
}

func (fake *fakeDockerClient) RegistryLoginReturns(result1 registry.AuthenticateOKBody, result2 error) {
	fake.RegistryLoginStub = nil
	fake.registryLoginReturns = struct {
		result1 registry.AuthenticateOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) RegistryLoginReturnsOnCall(i int, result1 registry.AuthenticateOKBody, result2 error) {
	fake.RegistryLoginStub = nil
	if fake.registryLoginReturnsOnCall == nil {
		fake.registryLoginReturnsOnCall = make(map[int]struct {
			result1 registry.AuthenticateOKBody
			result2 error
		})
	}
	fake.registryLoginReturnsOnCall[i] = struct {
		result1 registry.AuthenticateOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.networkConnectMutex.RLock()
	defer fake.networkConnectMutex.RUnlock()
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	fake.networkCreateMutex.RLock()
	defer fake.networkCreateMutex.RUnlock()
	fake.networkRemoveMutex.RLock()
	defer fake.networkRemoveMutex.RUnlock()
	fake.registryLoginMutex.RLock()
	defer fake.registryLoginMutex.RUnlock()
	return fake.invocations
}

func (fake *fakeDockerClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
