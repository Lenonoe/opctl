// This file was generated by counterfeiter
package containerprovider

import (
	"sync"

	"github.com/opspec-io/opctl/util/pubsub"
	"github.com/opspec-io/sdk-golang/pkg/model"
)

type Fake struct {
	InspectContainerIfExistsStub        func(containerId string) (container *model.DcgContainerCall, err error)
	inspectContainerIfExistsMutex       sync.RWMutex
	inspectContainerIfExistsArgsForCall []struct {
		containerId string
	}
	inspectContainerIfExistsReturns struct {
		result1 *model.DcgContainerCall
		result2 error
	}
	DeleteContainerIfExistsStub        func(containerId string)
	deleteContainerIfExistsMutex       sync.RWMutex
	deleteContainerIfExistsArgsForCall []struct {
		containerId string
	}
	StartContainerStub        func(req *StartContainerReq, eventPublisher pubsub.EventPublisher) (err error)
	startContainerMutex       sync.RWMutex
	startContainerArgsForCall []struct {
		req            *StartContainerReq
		eventPublisher pubsub.EventPublisher
	}
	startContainerReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Fake) InspectContainerIfExists(containerId string) (container *model.DcgContainerCall, err error) {
	fake.inspectContainerIfExistsMutex.Lock()
	fake.inspectContainerIfExistsArgsForCall = append(fake.inspectContainerIfExistsArgsForCall, struct {
		containerId string
	}{containerId})
	fake.recordInvocation("InspectContainerIfExists", []interface{}{containerId})
	fake.inspectContainerIfExistsMutex.Unlock()
	if fake.InspectContainerIfExistsStub != nil {
		return fake.InspectContainerIfExistsStub(containerId)
	} else {
		return fake.inspectContainerIfExistsReturns.result1, fake.inspectContainerIfExistsReturns.result2
	}
}

func (fake *Fake) InspectContainerIfExistsCallCount() int {
	fake.inspectContainerIfExistsMutex.RLock()
	defer fake.inspectContainerIfExistsMutex.RUnlock()
	return len(fake.inspectContainerIfExistsArgsForCall)
}

func (fake *Fake) InspectContainerIfExistsArgsForCall(i int) string {
	fake.inspectContainerIfExistsMutex.RLock()
	defer fake.inspectContainerIfExistsMutex.RUnlock()
	return fake.inspectContainerIfExistsArgsForCall[i].containerId
}

func (fake *Fake) InspectContainerIfExistsReturns(result1 *model.DcgContainerCall, result2 error) {
	fake.InspectContainerIfExistsStub = nil
	fake.inspectContainerIfExistsReturns = struct {
		result1 *model.DcgContainerCall
		result2 error
	}{result1, result2}
}

func (fake *Fake) DeleteContainerIfExists(containerId string) {
	fake.deleteContainerIfExistsMutex.Lock()
	fake.deleteContainerIfExistsArgsForCall = append(fake.deleteContainerIfExistsArgsForCall, struct {
		containerId string
	}{containerId})
	fake.recordInvocation("DeleteContainerIfExists", []interface{}{containerId})
	fake.deleteContainerIfExistsMutex.Unlock()
	if fake.DeleteContainerIfExistsStub != nil {
		fake.DeleteContainerIfExistsStub(containerId)
	}
}

func (fake *Fake) DeleteContainerIfExistsCallCount() int {
	fake.deleteContainerIfExistsMutex.RLock()
	defer fake.deleteContainerIfExistsMutex.RUnlock()
	return len(fake.deleteContainerIfExistsArgsForCall)
}

func (fake *Fake) DeleteContainerIfExistsArgsForCall(i int) string {
	fake.deleteContainerIfExistsMutex.RLock()
	defer fake.deleteContainerIfExistsMutex.RUnlock()
	return fake.deleteContainerIfExistsArgsForCall[i].containerId
}

func (fake *Fake) StartContainer(req *StartContainerReq, eventPublisher pubsub.EventPublisher) (err error) {
	fake.startContainerMutex.Lock()
	fake.startContainerArgsForCall = append(fake.startContainerArgsForCall, struct {
		req            *StartContainerReq
		eventPublisher pubsub.EventPublisher
	}{req, eventPublisher})
	fake.recordInvocation("StartContainer", []interface{}{req, eventPublisher})
	fake.startContainerMutex.Unlock()
	if fake.StartContainerStub != nil {
		return fake.StartContainerStub(req, eventPublisher)
	} else {
		return fake.startContainerReturns.result1
	}
}

func (fake *Fake) StartContainerCallCount() int {
	fake.startContainerMutex.RLock()
	defer fake.startContainerMutex.RUnlock()
	return len(fake.startContainerArgsForCall)
}

func (fake *Fake) StartContainerArgsForCall(i int) (*StartContainerReq, pubsub.EventPublisher) {
	fake.startContainerMutex.RLock()
	defer fake.startContainerMutex.RUnlock()
	return fake.startContainerArgsForCall[i].req, fake.startContainerArgsForCall[i].eventPublisher
}

func (fake *Fake) StartContainerReturns(result1 error) {
	fake.StartContainerStub = nil
	fake.startContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *Fake) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.inspectContainerIfExistsMutex.RLock()
	defer fake.inspectContainerIfExistsMutex.RUnlock()
	fake.deleteContainerIfExistsMutex.RLock()
	defer fake.deleteContainerIfExistsMutex.RUnlock()
	fake.startContainerMutex.RLock()
	defer fake.startContainerMutex.RUnlock()
	return fake.invocations
}

func (fake *Fake) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ContainerProvider = new(Fake)
