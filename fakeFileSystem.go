// This file was generated by counterfeiter
package sdk

import (
  "sync"
)

type FakeFilesystem struct {
  CreateDirStub             func(pathToDir string) (err error)
  createDirMutex            sync.RWMutex
  createDirArgsForCall      []struct {
    pathToDir string
  }
  createDirReturns          struct {
                              result1 error
                            }
  GetBytesOfFileStub        func(pathToFile string) (bytesOfFile []byte, err error)
  getBytesOfFileMutex       sync.RWMutex
  getBytesOfFileArgsForCall []struct {
    pathToFile string
  }
  getBytesOfFileReturns     struct {
                              result1 []byte
                              result2 error
                            }
  SaveFileStub              func(pathToFile string, bytesOfFile []byte) (err error)
  saveFileMutex             sync.RWMutex
  saveFileArgsForCall       []struct {
    pathToFile  string
    bytesOfFile []byte
  }
  saveFileReturns           struct {
                              result1 error
                            }
  invocations               map[string][][]interface{}
  invocationsMutex          sync.RWMutex
}

func (fake *FakeFilesystem) CreateDir(pathToDir string) (err error) {
  fake.createDirMutex.Lock()
  fake.createDirArgsForCall = append(fake.createDirArgsForCall, struct {
    pathToDir string
  }{pathToDir})
  fake.recordInvocation("CreateDir", []interface{}{pathToDir})
  fake.createDirMutex.Unlock()
  if fake.CreateDirStub != nil {
    return fake.CreateDirStub(pathToDir)
  } else {
    return fake.createDirReturns.result1
  }
}

func (fake *FakeFilesystem) CreateDirCallCount() int {
  fake.createDirMutex.RLock()
  defer fake.createDirMutex.RUnlock()
  return len(fake.createDirArgsForCall)
}

func (fake *FakeFilesystem) CreateDirArgsForCall(i int) string {
  fake.createDirMutex.RLock()
  defer fake.createDirMutex.RUnlock()
  return fake.createDirArgsForCall[i].pathToDir
}

func (fake *FakeFilesystem) CreateDirReturns(result1 error) {
  fake.CreateDirStub = nil
  fake.createDirReturns = struct {
    result1 error
  }{result1}
}

func (fake *FakeFilesystem) GetBytesOfFile(pathToFile string) (bytesOfFile []byte, err error) {
  fake.getBytesOfFileMutex.Lock()
  fake.getBytesOfFileArgsForCall = append(fake.getBytesOfFileArgsForCall, struct {
    pathToFile string
  }{pathToFile})
  fake.recordInvocation("GetBytesOfFile", []interface{}{pathToFile})
  fake.getBytesOfFileMutex.Unlock()
  if fake.GetBytesOfFileStub != nil {
    return fake.GetBytesOfFileStub(pathToFile)
  } else {
    return fake.getBytesOfFileReturns.result1, fake.getBytesOfFileReturns.result2
  }
}

func (fake *FakeFilesystem) GetBytesOfFileCallCount() int {
  fake.getBytesOfFileMutex.RLock()
  defer fake.getBytesOfFileMutex.RUnlock()
  return len(fake.getBytesOfFileArgsForCall)
}

func (fake *FakeFilesystem) GetBytesOfFileArgsForCall(i int) string {
  fake.getBytesOfFileMutex.RLock()
  defer fake.getBytesOfFileMutex.RUnlock()
  return fake.getBytesOfFileArgsForCall[i].pathToFile
}

func (fake *FakeFilesystem) GetBytesOfFileReturns(result1 []byte, result2 error) {
  fake.GetBytesOfFileStub = nil
  fake.getBytesOfFileReturns = struct {
    result1 []byte
    result2 error
  }{result1, result2}
}

func (fake *FakeFilesystem) SaveFile(pathToFile string, bytesOfFile []byte) (err error) {
  var bytesOfFileCopy []byte
  if bytesOfFile != nil {
    bytesOfFileCopy = make([]byte, len(bytesOfFile))
    copy(bytesOfFileCopy, bytesOfFile)
  }
  fake.saveFileMutex.Lock()
  fake.saveFileArgsForCall = append(fake.saveFileArgsForCall, struct {
    pathToFile  string
    bytesOfFile []byte
  }{pathToFile, bytesOfFileCopy})
  fake.recordInvocation("SaveFile", []interface{}{pathToFile, bytesOfFileCopy})
  fake.saveFileMutex.Unlock()
  if fake.SaveFileStub != nil {
    return fake.SaveFileStub(pathToFile, bytesOfFile)
  } else {
    return fake.saveFileReturns.result1
  }
}

func (fake *FakeFilesystem) SaveFileCallCount() int {
  fake.saveFileMutex.RLock()
  defer fake.saveFileMutex.RUnlock()
  return len(fake.saveFileArgsForCall)
}

func (fake *FakeFilesystem) SaveFileArgsForCall(i int) (string, []byte) {
  fake.saveFileMutex.RLock()
  defer fake.saveFileMutex.RUnlock()
  return fake.saveFileArgsForCall[i].pathToFile, fake.saveFileArgsForCall[i].bytesOfFile
}

func (fake *FakeFilesystem) SaveFileReturns(result1 error) {
  fake.SaveFileStub = nil
  fake.saveFileReturns = struct {
    result1 error
  }{result1}
}

func (fake *FakeFilesystem) Invocations() map[string][][]interface{} {
  fake.invocationsMutex.RLock()
  defer fake.invocationsMutex.RUnlock()
  fake.createDirMutex.RLock()
  defer fake.createDirMutex.RUnlock()
  fake.getBytesOfFileMutex.RLock()
  defer fake.getBytesOfFileMutex.RUnlock()
  fake.saveFileMutex.RLock()
  defer fake.saveFileMutex.RUnlock()
  return fake.invocations
}

func (fake *FakeFilesystem) recordInvocation(key string, args []interface{}) {
  fake.invocationsMutex.Lock()
  defer fake.invocationsMutex.Unlock()
  if fake.invocations == nil {
    fake.invocations = map[string][][]interface{}{}
  }
  if fake.invocations[key] == nil {
    fake.invocations[key] = [][]interface{}{}
  }
  fake.invocations[key] = append(fake.invocations[key], args)
}

var _ Filesystem = new(FakeFilesystem)
