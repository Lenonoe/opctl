// This file was generated by counterfeiter
package sdk

import (
  "sync"
)

type FakeFilesystem struct {
  AddDirStub             func(pathToDir string) (err error)
  addDirMutex            sync.RWMutex
  addDirArgsForCall      []struct {
    pathToDir string
  }
  addDirReturns          struct {
                              result1 error
                            }
  GetBytesOfFileStub        func(pathToFile string) (bytesOfFile []byte, err error)
  getBytesOfFileMutex       sync.RWMutex
  getBytesOfFileArgsForCall []struct {
    pathToFile string
  }
  getBytesOfFileReturns     struct {
                              result1 []byte
                              result2 error
                            }
  SaveFileStub              func(pathToFile string, bytesOfFile []byte) (err error)
  saveFileMutex             sync.RWMutex
  saveFileArgsForCall       []struct {
    pathToFile  string
    bytesOfFile []byte
  }
  saveFileReturns           struct {
                              result1 error
                            }
  invocations               map[string][][]interface{}
  invocationsMutex          sync.RWMutex
}

func (fake *FakeFilesystem) AddDir(pathToDir string) (err error) {
  fake.addDirMutex.Lock()
  fake.addDirArgsForCall = append(fake.addDirArgsForCall, struct {
    pathToDir string
  }{pathToDir})
  fake.recordInvocation("AddDir", []interface{}{pathToDir})
  fake.addDirMutex.Unlock()
  if fake.AddDirStub != nil {
    return fake.AddDirStub(pathToDir)
  } else {
    return fake.addDirReturns.result1
  }
}

func (fake *FakeFilesystem) AddDirCallCount() int {
  fake.addDirMutex.RLock()
  defer fake.addDirMutex.RUnlock()
  return len(fake.addDirArgsForCall)
}

func (fake *FakeFilesystem) AddDirArgsForCall(i int) string {
  fake.addDirMutex.RLock()
  defer fake.addDirMutex.RUnlock()
  return fake.addDirArgsForCall[i].pathToDir
}

func (fake *FakeFilesystem) AddDirReturns(result1 error) {
  fake.AddDirStub = nil
  fake.addDirReturns = struct {
    result1 error
  }{result1}
}

func (fake *FakeFilesystem) GetBytesOfFile(pathToFile string) (bytesOfFile []byte, err error) {
  fake.getBytesOfFileMutex.Lock()
  fake.getBytesOfFileArgsForCall = append(fake.getBytesOfFileArgsForCall, struct {
    pathToFile string
  }{pathToFile})
  fake.recordInvocation("GetBytesOfFile", []interface{}{pathToFile})
  fake.getBytesOfFileMutex.Unlock()
  if fake.GetBytesOfFileStub != nil {
    return fake.GetBytesOfFileStub(pathToFile)
  } else {
    return fake.getBytesOfFileReturns.result1, fake.getBytesOfFileReturns.result2
  }
}

func (fake *FakeFilesystem) GetBytesOfFileCallCount() int {
  fake.getBytesOfFileMutex.RLock()
  defer fake.getBytesOfFileMutex.RUnlock()
  return len(fake.getBytesOfFileArgsForCall)
}

func (fake *FakeFilesystem) GetBytesOfFileArgsForCall(i int) string {
  fake.getBytesOfFileMutex.RLock()
  defer fake.getBytesOfFileMutex.RUnlock()
  return fake.getBytesOfFileArgsForCall[i].pathToFile
}

func (fake *FakeFilesystem) GetBytesOfFileReturns(result1 []byte, result2 error) {
  fake.GetBytesOfFileStub = nil
  fake.getBytesOfFileReturns = struct {
    result1 []byte
    result2 error
  }{result1, result2}
}

func (fake *FakeFilesystem) SaveFile(pathToFile string, bytesOfFile []byte) (err error) {
  var bytesOfFileCopy []byte
  if bytesOfFile != nil {
    bytesOfFileCopy = make([]byte, len(bytesOfFile))
    copy(bytesOfFileCopy, bytesOfFile)
  }
  fake.saveFileMutex.Lock()
  fake.saveFileArgsForCall = append(fake.saveFileArgsForCall, struct {
    pathToFile  string
    bytesOfFile []byte
  }{pathToFile, bytesOfFileCopy})
  fake.recordInvocation("SaveFile", []interface{}{pathToFile, bytesOfFileCopy})
  fake.saveFileMutex.Unlock()
  if fake.SaveFileStub != nil {
    return fake.SaveFileStub(pathToFile, bytesOfFile)
  } else {
    return fake.saveFileReturns.result1
  }
}

func (fake *FakeFilesystem) SaveFileCallCount() int {
  fake.saveFileMutex.RLock()
  defer fake.saveFileMutex.RUnlock()
  return len(fake.saveFileArgsForCall)
}

func (fake *FakeFilesystem) SaveFileArgsForCall(i int) (string, []byte) {
  fake.saveFileMutex.RLock()
  defer fake.saveFileMutex.RUnlock()
  return fake.saveFileArgsForCall[i].pathToFile, fake.saveFileArgsForCall[i].bytesOfFile
}

func (fake *FakeFilesystem) SaveFileReturns(result1 error) {
  fake.SaveFileStub = nil
  fake.saveFileReturns = struct {
    result1 error
  }{result1}
}

func (fake *FakeFilesystem) Invocations() map[string][][]interface{} {
  fake.invocationsMutex.RLock()
  defer fake.invocationsMutex.RUnlock()
  fake.addDirMutex.RLock()
  defer fake.addDirMutex.RUnlock()
  fake.getBytesOfFileMutex.RLock()
  defer fake.getBytesOfFileMutex.RUnlock()
  fake.saveFileMutex.RLock()
  defer fake.saveFileMutex.RUnlock()
  return fake.invocations
}

func (fake *FakeFilesystem) recordInvocation(key string, args []interface{}) {
  fake.invocationsMutex.Lock()
  defer fake.invocationsMutex.Unlock()
  if fake.invocations == nil {
    fake.invocations = map[string][][]interface{}{}
  }
  if fake.invocations[key] == nil {
    fake.invocations[key] = [][]interface{}{}
  }
  fake.invocations[key] = append(fake.invocations[key], args)
}

var _ Filesystem = new(FakeFilesystem)
